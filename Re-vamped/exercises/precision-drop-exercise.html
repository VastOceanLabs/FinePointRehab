<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Precision Drop ‚Äî Fine Point Rehab</title>

  <link rel="stylesheet" href="/css/tokens.css">
  <link rel="stylesheet" href="/css/base.css">
  <link rel="stylesheet" href="/css/components.css">

  <style>
    :root{
      --vh: 1vh;
      --bg-1:#070b16; --bg-2:#0f1630; --bg-3:#0b1024;
      --accent: var(--brand-aqua, #6fd3f5);
      --panel: rgba(10,16,36,.9);
      --panel-border: rgba(255,255,255,.08);
      --text: #eaf6ff;
      --radius: 14px;
      --gold: #ffd700;
      --success: #2ecc71;
      --warning: #f39c12;
    }
    body{ margin:0; color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 25%, rgba(70,30,120,.35), transparent 60%),
        radial-gradient(900px 700px at 75% 65%, rgba(20,120,160,.28), transparent 55%),
        linear-gradient(180deg, var(--bg-1) 0%, var(--bg-2) 50%, var(--bg-3) 100%);
      min-height: calc(var(--vh) * 100);
      touch-action: manipulation;
    }
    body.playing { overflow: hidden; }
    body.playing header.app { display: none; }

    header.app{
      position: sticky; top:0; z-index: 50;
      padding:12px 16px; display:flex; gap:12px; align-items:center;
      background: linear-gradient(180deg, rgba(8,12,26,.9), rgba(8,12,26,.55));
      border-bottom: 1px solid rgba(255,255,255,.06);
      backdrop-filter: blur(6px);
    }
    header .home { text-decoration:none; color:var(--text); font-weight:700;
      border:1px solid rgba(255,255,255,.18); border-radius:999px; padding:8px 12px; }
    header h1{ margin:0; font-size: clamp(18px,3vw,24px); }

    .layout{ display:grid; grid-template-columns: 1fr; gap:16px; padding:16px; height:auto; }
    .panel{ background: var(--panel); border: 1px solid var(--panel-border); border-radius: var(--radius);
            box-shadow: 0 10px 30px rgba(0,0,0,.5), 0 0 0 1px rgba(255,255,255,.05); }

    #settings { padding:18px; overflow:auto; position:relative; z-index: 5; max-width: 720px; margin: 0 auto; }
    #settings h2{ margin:0 0 10px; font-size:20px; text-align:center; }
    .desc{ margin-bottom:12px; background: rgba(111,211,245,.08);
          border-left: 4px solid rgba(111,211,245,.7); padding:10px; border-radius:8px; font-size:14px; line-height:1.5; }

    .stats-row{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-bottom:12px; }
    .metric{ flex:0 0 auto; display:flex; flex-direction:column; align-items:center; justify-content:center;
            text-align:center; padding:8px 12px; border:1px solid rgba(255,255,255,.12); border-radius:12px;
            background: rgba(255,255,255,.05); min-width:80px; }
    .v{ font-weight:900; font-size:18px; color:#bfe6ff; text-shadow: 0 0 6px rgba(150,220,255,.5); line-height:1.1; }
    .t{ font-size:11px; opacity:.9; margin-top:3px; }

    .group{ margin-bottom:12px; }
    .label{ display:block; margin-bottom:6px; font-weight:700; letter-spacing:.2px; }
    select, input[type="number"]{
      width:100%; padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,.2);
      background: rgba(5,10,26,.8); color:var(--text); font-size:16px;
    }
    select:focus, input[type="number"]:focus{
      outline:none; border-color: rgba(111,211,245,.9); box-shadow: 0 0 0 2px rgba(111,211,245,.25);
    }
    .btn{
      min-height:46px; border:1px solid rgba(111,211,245,.35); background: rgba(111,211,245,.12);
      color:var(--text); border-radius:10px; font-weight:800; letter-spacing:.2px; cursor:pointer; transition:.2s;
    }
    .btn:hover:not(:disabled){ background: rgba(111,211,245,.22); transform: translateY(-1px); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }
    .btn-primary{ background: rgba(111,211,245,.95); color:#07101e; border-color: rgba(111,211,245,1); }
    .btn-primary:hover:not(:disabled){ background: rgba(111,211,245,1); box-shadow: 0 6px 18px rgba(111,211,245,.45); }

    .settings-actions { display:grid; grid-template-columns: 1fr; gap:10px; margin-top:12px; }

    .right{ display:none; position:relative; }
    body.playing .right{ display:block; }

    .hud{ display:flex; flex-wrap:wrap; align-items:center; gap:6px; padding:8px 10px; margin-bottom:10px;
          background: linear-gradient(180deg, rgba(6,10,24,.85), rgba(6,10,24,.65));
          border: 1px solid var(--panel-border); border-radius: var(--radius);
          box-shadow: 0 6px 16px rgba(0,0,0,.35); position:relative; z-index:4; }
    .actions{ flex:0 0 auto; display:flex; gap:8px; margin-left:auto; }
    .btn-ghost{ min-height:34px; padding:6px 10px; font-weight:800; border:1px solid rgba(255,255,255,.22);
                border-radius:999px; background: rgba(255,255,255,.06); color:var(--text); cursor:pointer; white-space:nowrap; }
    .btn-ghost:hover{ background: rgba(255,255,255,.12); }
    .metric .v.time { font-variant-numeric: tabular-nums; }

    /* Combo display in HUD */
    .combo-display { 
      display: flex; align-items: center; gap: 6px; 
      padding: 4px 12px; border-radius: 999px;
      background: linear-gradient(135deg, rgba(255,215,0,.2), rgba(255,165,0,.15));
      border: 1px solid rgba(255,215,0,.4);
      opacity: 0; transform: scale(0.8);
      transition: opacity .3s, transform .3s;
    }
    .combo-display.active { opacity: 1; transform: scale(1); }
    .combo-display .combo-val { 
      font-weight: 900; font-size: 16px; 
      color: var(--gold); 
      text-shadow: 0 0 10px rgba(255,215,0,.6);
    }
    .combo-display .combo-label { font-size: 10px; opacity: .9; }

    /* Streak indicator */
    .streak-fire { 
      font-size: 18px; 
      animation: fireWiggle .5s ease-in-out infinite;
    }
    @keyframes fireWiggle {
      0%, 100% { transform: rotate(-5deg) scale(1); }
      50% { transform: rotate(5deg) scale(1.1); }
    }

    .frame{ position:relative; border-radius: var(--radius); overflow:hidden;
            border:1px solid var(--panel-border); box-shadow: inset 0 0 40px rgba(0,0,0,.35);
            background: radial-gradient(60% 45% at 50% 40%, rgba(80,160,200,.12), transparent 68%); }
    #game-surface{ position:relative; min-height: 58vh; max-height:760px; background: transparent; }
    #stars-container{ position:absolute; inset:0; pointer-events:none; z-index:1; overflow:hidden; }
    #game-area{ position: relative; width: 100%; height: 100%; }

    body.playing .layout{ grid-template-columns: 1fr; padding:0; height: calc(var(--vh) * 100); }
    body.playing #settings{ display:none; }
    body.playing .right{ height: calc(var(--vh) * 100); }
    body.playing .frame{ border:none; border-radius:0; height: calc(var(--vh) * 100); box-shadow: none; background: transparent; }
    body.playing #game-surface{ width:100vw; height: calc(var(--vh) * 100); max-height:none; }
    body.playing .hud{
      position:absolute; top: calc(env(safe-area-inset-top, 0px) + 10px); left: 10px; right: 10px; margin:0;
    }

    .draggable{
      position:absolute; border-radius:50%; cursor: grab; touch-action: none;
      display:flex; align-items:center; justify-content:center; font-weight:800; color:#fff;
      text-shadow: 0 1px 3px rgba(0,0,0,.5); box-shadow: 0 4px 15px rgba(0,0,0,.3);
      transition: transform .2s ease, box-shadow .2s ease; z-index: 100; animation: float 3s ease-in-out infinite;
    }
    .draggable.dragging{ cursor:grabbing; transform: scale(1.12); animation:none; z-index: 200; 
      box-shadow: 0 8px 25px rgba(0,0,0,.5), 0 0 20px currentColor;
    }
    @keyframes float{ 0%,100%{transform:translateY(0)} 50%{transform:translateY(-4px)} }

    /* Shape indicators for accessibility */
    .draggable .shape-indicator, .target .shape-indicator {
      position: absolute; opacity: 0.6; pointer-events: none;
    }

    .target{
      position:absolute; border:3px dashed rgba(255,255,255,.3); border-radius:50%;
      background: radial-gradient(circle at center, transparent 40%, rgba(255,255,255,.03) 100%);
      transition: transform .2s ease, box-shadow .2s ease, border-color .2s; z-index: 50;
      display: flex; align-items: center; justify-content: center;
    }
    .target.active{ 
      box-shadow: 0 0 30px currentColor, inset 0 0 20px rgba(255,255,255,.1); 
      transform: scale(1.08); 
      border-style: solid;
      border-width: 4px;
    }
    .target.success{ animation: burst .6s ease; }
    .target.wrong-hint {
      animation: wrongShake .4s ease;
    }
    @keyframes burst{ 0%{transform:scale(1);opacity:1} 50%{transform:scale(1.3);opacity:.7} 100%{transform:scale(1);opacity:1} }
    @keyframes wrongShake {
      0%, 100% { transform: translateX(0); }
      20%, 60% { transform: translateX(-5px); }
      40%, 80% { transform: translateX(5px); }
    }

    #status-message{
      position:absolute; top:14%; left:50%; transform:translateX(-50%);
      z-index:3; font-weight:800; text-shadow:0 2px 8px rgba(0,0,0,.5);
      transition: opacity .3s;
    }
    #progress-display{
      position:absolute; top:20px; left:50%; transform:translateX(-50%);
      z-index:3; background: rgba(0,0,0,.55); padding: 6px 14px; border-radius: 999px;
      font-weight:700; box-shadow:0 4px 10px rgba(0,0,0,.3);
    }

    /* Floating score popup */
    .score-popup {
      position: absolute; pointer-events: none; z-index: 100;
      font-weight: 900; font-size: 20px;
      text-shadow: 0 2px 10px rgba(0,0,0,.5);
      animation: scoreFloat 1.2s ease-out forwards;
    }
    .score-popup.combo { 
      font-size: 26px; 
      color: var(--gold) !important;
    }
    .score-popup.speed-bonus {
      font-size: 16px;
      color: #2ecc71 !important;
    }
    @keyframes scoreFloat {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      20% { transform: translateY(-20px) scale(1.2); }
      100% { opacity: 0; transform: translateY(-80px) scale(0.8); }
    }

    /* Speed indicator */
    .speed-indicator {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      z-index: 5; display: flex; align-items: center; gap: 8px;
      background: rgba(0,0,0,.6); padding: 8px 16px; border-radius: 999px;
      font-size: 14px; font-weight: 700;
      opacity: 0; transition: opacity .3s;
    }
    .speed-indicator.visible { opacity: 1; }
    .speed-dot {
      width: 12px; height: 12px; border-radius: 50%;
      transition: background .3s;
    }
    .speed-dot.fast { background: #2ecc71; box-shadow: 0 0 10px #2ecc71; }
    .speed-dot.medium { background: #f39c12; box-shadow: 0 0 10px #f39c12; }
    .speed-dot.slow { background: #e74c3c; box-shadow: 0 0 10px #e74c3c; }

    /* Particles container */
    #particles-container {
      position: absolute; inset: 0; pointer-events: none; z-index: 90; overflow: hidden;
    }
    .particle {
      position: absolute; border-radius: 50%; pointer-events: none;
      animation: particleBurst .8s ease-out forwards;
    }
    @keyframes particleBurst {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0); }
    }

    /* Screen flash on combo */
    .screen-flash {
      position: fixed; inset: 0; pointer-events: none; z-index: 200;
      background: radial-gradient(circle at center, rgba(255,215,0,.3), transparent 70%);
      opacity: 0; animation: flashPulse .4s ease-out;
    }
    @keyframes flashPulse {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Pause overlay */
    .pause-overlay {
      position: absolute; inset: 0; z-index: 8;
      background: rgba(0,0,0,.7); backdrop-filter: blur(8px);
      display: none; place-items: center;
      font-size: 48px; font-weight: 900; color: var(--accent);
      text-shadow: 0 0 30px var(--accent);
    }
    .pause-overlay.visible { display: grid; }

    /* Near miss message */
    .near-miss-msg {
      position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
      z-index: 60; font-weight: 800; font-size: 24px;
      padding: 12px 24px; border-radius: 12px;
      background: rgba(231, 76, 60, .9);
      color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,.3);
      animation: nearMissAnim .8s ease-out forwards;
      pointer-events: none;
    }
    @keyframes nearMissAnim {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
      30% { transform: translate(-50%, -50%) scale(1); }
      80% { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -50%) translateY(-20px); }
    }

    #completion-modal{ position:absolute; inset:0; display:none; place-items:center; background: rgba(0,0,0,.65);
                       backdrop-filter: blur(4px); z-index:10; }
    #completion-card{ max-width:min(560px, 92vw); max-height:80vh; overflow:auto; padding:22px; }
    #completion-card h2{ margin-top:0; color:var(--accent); }
    .hi{ color:#9ee7ff; font-weight:900; }

    /* New PB celebration */
    .new-pb-badge {
      display: inline-block; padding: 4px 12px; margin-left: 8px;
      background: linear-gradient(135deg, var(--gold), #ff8c00);
      color: #000; font-weight: 900; font-size: 12px;
      border-radius: 999px; animation: pbPulse 1s ease-in-out infinite;
    }
    @keyframes pbPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    /* Confetti */
    .confetti {
      position: fixed; top: -10px; width: 10px; height: 10px;
      pointer-events: none; z-index: 300;
      animation: confettiFall 3s ease-out forwards;
    }
    @keyframes confettiFall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }

    /* Stats grid in completion */
    .stats-grid {
      display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;
      margin: 16px 0;
    }
    .stat-card {
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.1);
      border-radius: 12px; padding: 12px; text-align: center;
    }
    .stat-card .stat-value {
      font-size: 28px; font-weight: 900; color: var(--accent);
      text-shadow: 0 0 15px rgba(111,211,245,.4);
    }
    .stat-card .stat-label {
      font-size: 12px; opacity: .8; margin-top: 4px;
    }
    .stat-card.highlight {
      background: linear-gradient(135deg, rgba(255,215,0,.15), rgba(255,165,0,.1));
      border-color: rgba(255,215,0,.3);
    }
    .stat-card.highlight .stat-value { color: var(--gold); }

    /* Achievements in completion */
    .achievements-earned {
      margin-top: 16px; padding-top: 16px;
      border-top: 1px solid rgba(255,255,255,.1);
    }
    .achievements-earned h3 {
      margin: 0 0 12px; font-size: 14px; opacity: .8;
    }
    .achievement-badge {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 12px; margin: 4px;
      background: rgba(46, 204, 113, .2);
      border: 1px solid rgba(46, 204, 113, .4);
      border-radius: 999px; font-size: 12px; font-weight: 700;
    }

    .sr-only{ position:absolute !important; clip:rect(1px,1px,1px,1px); padding:0; border:0; height:1px; width:1px; overflow:hidden; }
    :focus-visible{ outline: 3px solid rgba(111,211,245,.85); outline-offset:2px; }
    @media (max-width: 900px){ #game-surface{ min-height:56vh; } }
    @media (prefers-reduced-motion: reduce){
      *{ animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; }
    }
  </style>
</head>
<body>
  <header class="app" role="banner" aria-label="Exercise header">
    <a class="home" href="/" aria-label="Back to Home">‚Üê Home</a>
    <h1>Precision Drop</h1>
  </header>

  <main class="layout">
    <aside id="settings" class="panel" aria-label="Settings">
      <h2>Settings</h2>
      <div class="desc"><strong>How to play:</strong> Drag each coloured circle to its matching target. Targets glow when you're close. Build combos for bonus points! üî•</div>
      <div class="stats-row" role="region" aria-label="Player stats">
        <div class="metric" aria-live="polite">
          <div id="pbSettings" class="v">‚Äì</div>
          <div class="t">Personal Best</div>
        </div>
        <div class="metric">
          <div id="bestStreak" class="v">‚Äì</div>
          <div class="t">Best Streak</div>
        </div>
      </div>

      <div class="group">
        <label class="label" for="session-duration">Session Duration (minutes)</label>
        <input id="session-duration" type="number" min="1" max="10" value="2" inputmode="numeric" />
      </div>
      <div class="group">
        <label class="label" for="difficulty-select">Target Size</label>
        <select id="difficulty-select">
          <option value="easy" selected>Easy (large targets)</option>
          <option value="medium">Medium</option>
          <option value="hard">Hard (small targets)</option>
        </select>
      </div>
      <div class="group">
        <label class="label" for="num-targets">Objects per round</label>
        <select id="num-targets">
          <option value="1" selected>1</option>
          <option value="2">2</option>
          <option value="3">3</option>
        </select>
      </div>
      <div class="group">
        <label class="label" for="show-numbers">Show numbers</label>
        <select id="show-numbers">
          <option value="no" selected>No</option>
          <option value="yes">Yes</option>
        </select>
      </div>
      <div class="group">
        <label class="label" for="show-shapes">Shape hints (accessibility)</label>
        <select id="show-shapes">
          <option value="no" selected>No</option>
          <option value="yes">Yes</option>
        </select>
      </div>
      <div class="group">
        <label class="label" for="sound-toggle">Sound effects</label>
        <select id="sound-toggle">
          <option value="yes" selected>On</option>
          <option value="no">Off</option>
        </select>
      </div>

      <div class="settings-actions">
        <button id="start-button" class="btn btn-primary" type="button">Start</button>
      </div>
    </aside>

    <section class="right" aria-label="Game area">
      <div class="hud" role="region" aria-label="Session HUD">
        <div class="metric" aria-live="polite"><div id="score" class="v">0</div><div class="t">Score</div></div>
        <div class="combo-display" id="combo-display">
          <span class="streak-fire">üî•</span>
          <div>
            <div class="combo-val" id="combo-val">x2</div>
            <div class="combo-label">COMBO</div>
          </div>
        </div>
        <div class="metric" aria-live="polite"><div id="pb" class="v">‚Äì</div><div class="t">PB</div></div>
        <div class="metric" aria-live="polite"><div id="time" class="v time">00:00</div><div class="t">Time</div></div>
        <div class="actions">
          <button id="pauseHud" class="btn-ghost" type="button" aria-label="Pause or resume">‚è∏</button>
          <button id="exitHud" class="btn-ghost" type="button" aria-label="Exit to results">‚úï</button>
        </div>
      </div>

      <div class="frame panel">
        <div id="game-surface" role="application" aria-describedby="progress-display status-message">
          <div id="stars-container" aria-hidden="true"></div>
          <div id="particles-container" aria-hidden="true"></div>
          <div id="progress-display" aria-live="polite">Round <span id="round-number">1</span> / <span id="total-rounds">10</span></div>
          <div id="status-message" aria-live="polite">Drag the object to the target</div>
          <div class="speed-indicator" id="speed-indicator">
            <div class="speed-dot" id="speed-dot"></div>
            <span id="speed-text">Quick!</span>
          </div>
          <div class="pause-overlay" id="pause-overlay">PAUSED</div>
          <div id="game-area" aria-label="Play field" tabindex="0"></div>
        </div>
      </div>

      <div id="completion-modal" role="dialog" aria-modal="true" aria-labelledby="completion-title">
        <div id="completion-card" class="panel" tabindex="-1">
          <h2 id="completion-title">Session Complete! <span id="new-pb-badge" class="new-pb-badge" style="display:none">NEW PB!</span></h2>
          
          <div class="stats-grid">
            <div class="stat-card highlight">
              <div class="stat-value" id="final-score">0</div>
              <div class="stat-label">Final Score</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="final-drops">0</div>
              <div class="stat-label">Successful Drops</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="final-accuracy">0%</div>
              <div class="stat-label">Accuracy</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="final-avg-time">0.00s</div>
              <div class="stat-label">Avg Time / Drop</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="final-best-combo">x1</div>
              <div class="stat-label">Best Combo</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="final-xp">+0</div>
              <div class="stat-label">XP Earned</div>
            </div>
          </div>

          <div id="achievements-section" class="achievements-earned" style="display:none">
            <h3>üèÜ Achievements Unlocked</h3>
            <div id="achievements-list"></div>
          </div>

          <div class="settings-actions" style="grid-template-columns:1fr 1fr;">
            <button id="doneBtn" class="btn btn-primary" type="button">Play Again</button>
            <button id="homeBtn" class="btn" type="button">Home</button>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
  (function(){
    const $ = (id)=>document.getElementById(id);

    // DOM
    const difficultySelect = $('difficulty-select');
    const numTargetsSelect = $('num-targets');
    const sessionDurationInput = $('session-duration');
    const showNumbersSelect = $('show-numbers');
    const showShapesSelect = $('show-shapes');
    const soundToggle = $('sound-toggle');

    const startBtn = $('start-button');
    const pauseHudBtn = $('pauseHud');
    const exitHudBtn = $('exitHud');
    const doneBtn = $('doneBtn');
    const homeBtn = $('homeBtn');

    const timeEl = $('time');
    const scoreEl = $('score');
    const personalBestEl = $('pb');
    const pbSettingsEl = $('pbSettings');
    const bestStreakEl = $('bestStreak');
    const comboDisplay = $('combo-display');
    const comboValEl = $('combo-val');

    const gameArea = $('game-area');
    const gameSurface = $('game-surface');
    const starsContainer = $('stars-container');
    const particlesContainer = $('particles-container');
    const pauseOverlay = $('pause-overlay');
    const speedIndicator = $('speed-indicator');
    const speedDot = $('speed-dot');
    const speedText = $('speed-text');

    const statusMessage = $('status-message');
    const progressDisplay = $('progress-display');
    const roundNumber = $('round-number');
    const totalRounds = $('total-rounds');

    const completionModal = $('completion-modal');
    const completionCard = $('completion-card');
    const finalScoreEl = $('final-score');
    const finalDropsEl = $('final-drops');
    const finalAccuracyEl = $('final-accuracy');
    const finalAvgTimeEl = $('final-avg-time');
    const finalBestComboEl = $('final-best-combo');
    const finalXpEl = $('final-xp');
    const newPbBadge = $('new-pb-badge');
    const achievementsSection = $('achievements-section');
    const achievementsList = $('achievements-list');

    // Fallbacks if imports fail
    let recordSession = ()=>{};
    let checkAndUnlockAchievements = ()=>[];
    let markExerciseTried = ()=>{};
    const storage = { get:(k)=>localStorage.getItem(k), set:(k,v)=>localStorage.setItem(k,v) };
    const sessionEnhancement = {
      initializeExercise: ()=>{},
      personalBest: { getBest: ()=>Number(localStorage.getItem('pb:precision-drop')||0) },
      handleSessionComplete: ()=>{}
    };

    (async function loadDeps(){
      try {
        const m1 = await import('/js/progress.js'); recordSession = m1.recordSession || recordSession;
      } catch(e){}
      try {
        const m2 = await import('/js/achievements.js');
        checkAndUnlockAchievements = m2.checkAndUnlockAchievements || checkAndUnlockAchievements;
        markExerciseTried = m2.markExerciseTried || markExerciseTried;
      } catch(e) {}
      try {
        const m3 = await import('/js/utils.js');
        if (m3.storage) { storage.get = m3.storage.get; storage.set = m3.storage.set; }
        if (m3.initUtils) { try { m3.initUtils(); } catch(e){} }
      } catch(e) {}
      try {
        const m4 = await import('/js/session-enhancement.js');
        if (m4.sessionEnhancement) {
          sessionEnhancement.initializeExercise = m4.sessionEnhancement.initializeExercise;
          sessionEnhancement.personalBest = m4.sessionEnhancement.personalBest || sessionEnhancement.personalBest;
          sessionEnhancement.handleSessionComplete = m4.sessionEnhancement.handleSessionComplete;
        }
      } catch(e) {}
    })();

    const EXERCISE_ID = 'precision-drop';

    // ========= Audio System =========
    const AudioSystem = {
      ctx: null,
      enabled: true,
      init() {
        if (this.ctx) return;
        try {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) { this.enabled = false; }
      },
      play(type) {
        if (!this.enabled || !this.ctx || (soundToggle?.value === 'no')) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        const now = this.ctx.currentTime;
        
        switch(type) {
          case 'drop':
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(900, now + 0.1);
            gain.gain.setValueAtTime(0.15, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
            break;
          case 'combo':
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.25);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
            osc.start(now);
            osc.stop(now + 0.35);
            break;
          case 'miss':
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
            break;
          case 'speedBonus':
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1000, now + 0.08);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
            osc.start(now);
            osc.stop(now + 0.12);
            break;
        }
      },
      haptic(duration = 50) {
        if (navigator.vibrate) {
          navigator.vibrate(duration);
        }
      }
    };

    // ========= Safe area helpers =========
    function getPlayableRect() {
      const areaRect = gameArea.getBoundingClientRect();
      
      // Safety check - if game area has no dimensions yet, return sensible defaults
      if (areaRect.width < 100 || areaRect.height < 100) {
        return { minX: 20, minY: 80, maxX: 300, maxY: 400, width: 320, height: 480, reserve: 80 };
      }
      
      const hud = document.querySelector('.hud');
      const hudRect = hud ? hud.getBoundingClientRect() : { height: 0, top: 0, bottom: 0 };
      const overlapTop = Math.max(0, Math.min(hudRect.bottom - areaRect.top, hudRect.height));
      const padTop = parseFloat(getComputedStyle(gameArea).paddingTop || '0') || 0;
      const reserve = Math.max(overlapTop, padTop, 60) + 20; // Ensure minimum reserve
      const minX = 20;
      const minY = reserve;
      const maxX = areaRect.width - 20;
      const maxY = areaRect.height - 20;
      return { minX, minY, maxX, maxY, width: areaRect.width, height: areaRect.height, reserve };
    }

    // ========= Game state =========
    let isSessionActive = false;
    let isPaused = false;
    let sessionDuration = 120000;
    let timeRemaining = 0;
    let timerInterval = null;
    let parityInterval = null;
    let speedUpdateInterval = null;

    let score = 0;
    let successfulDrops = 0;
    let totalDrops = 0;
    let currentRound = 1;
    let maxRounds = 10;

    let totalDropTime = 0;
    let roundStartTime = 0;
    let dropStartTime = 0;

    // Combo system
    let currentStreak = 0;
    let bestStreak = 0;
    let comboMultiplier = 1;

    let activeDroppables = [];
    let activeTargets = [];
    let currentDragging = null;
    let dragOffsetX = 0, dragOffsetY = 0;

    const DIFF = {
      easy: { targetSize: 90, objectSize: 50, points: 100, spacing: 120 },
      medium: { targetSize: 70, objectSize: 40, points: 200, spacing: 100 },
      hard: { targetSize: 55, objectSize: 32, points: 300, spacing: 80 }
    };

    const palette = [
      { solid:'#e74c3c', grad:'linear-gradient(135deg,#e74c3c,#c0392b)', shape:'‚óè' },
      { solid:'#f1c40f', grad:'linear-gradient(135deg,#f1c40f,#f39c12)', shape:'‚ñ≤' },
      { solid:'#2ecc71', grad:'linear-gradient(135deg,#2ecc71,#27ae60)', shape:'‚ñ†' },
      { solid:'#9b59b6', grad:'linear-gradient(135deg,#9b59b6,#8e44ad)', shape:'‚óÜ' },
      { solid:'#3498db', grad:'linear-gradient(135deg,#3498db,#2980b9)', shape:'‚òÖ' },
      { solid:'#e67e22', grad:'linear-gradient(135deg,#e67e22,#d35400)', shape:'‚ô•' },
      { solid:'#1abc9c', grad:'linear-gradient(135deg,#1abc9c,#16a085)', shape:'‚¨°' },
      { solid:'#34495e', grad:'linear-gradient(135deg,#5d6d7e,#34495e)', shape:'‚óØ' }
    ];

    // Speed bonus thresholds (ms)
    const SPEED_FAST = 1500;
    const SPEED_MEDIUM = 3000;

    // Starfield
    window.addEventListener('resize', () => { if(isSessionActive){ ensureParity(); } }, {passive:true});
    (function initTwinkle(){
      const count = 80;
      for (let i=0;i<count;i++){
        const s=document.createElement('div');
        s.style.cssText=`position:absolute; background:#fff; border-radius:50%; opacity:.25;`;
        s.style.left = `${Math.random()*100}%`;
        s.style.top = `${Math.random()*100}%`;
        const sz = 1 + Math.random()*2.5;
        s.style.width = `${sz}px`; s.style.height = `${sz}px`;
        s.style.animation = `twinkle ${3+Math.random()*2}s ease-in-out ${Math.random()*3}s infinite`;
        if (starsContainer) starsContainer.appendChild(s);
      }
      const tw = document.createElement('style');
      tw.textContent = `@keyframes twinkle{0%,100%{opacity:.2;transform:scale(1)}50%{opacity:.8;transform:scale(1.2)}}`;
      document.head.appendChild(tw);
    })();

    // ========= PB & Stats =========
    function initializeSessionEnhancement() {
      try { sessionEnhancement.initializeExercise(EXERCISE_ID, difficultySelect.value); } catch(e){}
      updatePersonalBestDisplay();
      updateBestStreakDisplay();
    }
    function updatePersonalBestDisplay() {
      try {
        const currentDifficulty = difficultySelect.value;
        const difficultyBest = sessionEnhancement.personalBest.getBest(EXERCISE_ID, currentDifficulty);
        if (personalBestEl) personalBestEl.textContent = difficultyBest > 0 ? difficultyBest : '‚Äì';
        if (pbSettingsEl) pbSettingsEl.textContent = difficultyBest > 0 ? difficultyBest : '‚Äì';
      } catch(e) {
        const PB_KEY = 'pb:'+EXERCISE_ID;
        const pb = Number(localStorage.getItem(PB_KEY) || 0);
        if (personalBestEl) personalBestEl.textContent = pb > 0 ? pb : '‚Äì';
        if (pbSettingsEl) pbSettingsEl.textContent = pb > 0 ? pb : '‚Äì';
      }
    }
    function updateBestStreakDisplay() {
      const storedStreak = Number(localStorage.getItem('streak:' + EXERCISE_ID) || 0);
      if (bestStreakEl) bestStreakEl.textContent = storedStreak > 0 ? storedStreak : '‚Äì';
    }
    function saveBestStreak(streak) {
      const key = 'streak:' + EXERCISE_ID;
      const current = Number(localStorage.getItem(key) || 0);
      if (streak > current) {
        localStorage.setItem(key, streak);
      }
    }
    initializeSessionEnhancement();
    if (difficultySelect) {
      difficultySelect.addEventListener('change', () => {
        initializeSessionEnhancement();
      });
    }

    // ========= Controls =========
    if (startBtn) startBtn.addEventListener('click', () => { 
      AudioSystem.init();
      if(!isSessionActive){ startSession(); } 
    });
    if (pauseHudBtn) pauseHudBtn.addEventListener('click', () => { if(isSessionActive){ togglePause(); } });
    if (exitHudBtn) exitHudBtn.addEventListener('click', () => { if(isSessionActive){ finishSession(); } });
    if (doneBtn) doneBtn.addEventListener('click', () => { restartSession(); });
    if (homeBtn) homeBtn.addEventListener('click', () => { window.location.href = '/'; });

    if (gameArea) gameArea.addEventListener('keydown', (e) => {
      const focusEl = document.activeElement;
      if(!focusEl?.classList?.contains('draggable')) return;
      const step = (e.shiftKey ? 10 : 4);
      const rect = gameArea.getBoundingClientRect();
      const r = focusEl.getBoundingClientRect();
      let x = r.left - rect.left, y = r.top - rect.top;
      let moved = false;
      if(e.key === 'ArrowLeft'){ x = Math.max(0, x - step); moved=true; }
      if(e.key === 'ArrowRight'){ x = Math.min(rect.width - r.width, x + step); moved=true; }
      if(e.key === 'ArrowUp'){ y = Math.max(0, y - step); moved=true; }
      if(e.key === 'ArrowDown'){ y = Math.min(rect.height - r.height, y + step); moved=true; }
      if(moved){ focusEl.style.left = `${x}px`; focusEl.style.top = `${y}px`; e.preventDefault(); checkProximity(); }
      if(e.key === 'Enter'){ e.preventDefault(); currentDragging = focusEl; checkDrop(); currentDragging=null; }
    });

    function fmtTime(ms){
      const s = Math.max(0, Math.ceil(ms/1000));
      const m = Math.floor(s/60);
      const ss = String(s%60).padStart(2,'0');
      return `${String(m).padStart(2,'0')}:${ss}`;
    }
    function updateTimeUI(){ if (timeEl) timeEl.textContent = fmtTime(timeRemaining); }

    // Detect iOS/iPadOS - skip fullscreen API to avoid data manipulation warning
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    async function enterFullscreen(){
      if (isIOS) return; // Skip fullscreen on iOS - causes security warning
      try{
        const el = document.documentElement;
        if (el.requestFullscreen) await el.requestFullscreen({ navigationUI: 'hide' });
        else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      }catch{}
    }
    async function exitFullscreen(){
      if (isIOS) return;
      try{
        if (document.fullscreenElement) await document.exitFullscreen();
        else if (document.webkitFullscreenElement) await document.webkitExitFullscreen();
      }catch{}
    }
    function toImmersive(){ document.body.classList.add('playing'); window.scrollTo({ top: 0 }); enterFullscreen(); }
    function fromImmersive(){ document.body.classList.remove('playing'); exitFullscreen(); }

    // ========= Visual Effects =========
    function createScorePopup(x, y, text, type = 'normal', color = '#fff') {
      const popup = document.createElement('div');
      popup.className = 'score-popup' + (type !== 'normal' ? ` ${type}` : '');
      popup.textContent = text;
      popup.style.left = `${x}px`;
      popup.style.top = `${y}px`;
      popup.style.color = color;
      gameArea.appendChild(popup);
      setTimeout(() => popup.remove(), 1200);
    }

    function createParticles(x, y, color, count = 12) {
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        const size = 4 + Math.random() * 8;
        const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
        const distance = 40 + Math.random() * 60;
        const endX = x + Math.cos(angle) * distance;
        const endY = y + Math.sin(angle) * distance;
        
        particle.style.cssText = `
          left: ${x}px; top: ${y}px;
          width: ${size}px; height: ${size}px;
          background: ${color};
          box-shadow: 0 0 ${size}px ${color};
        `;
        particle.style.setProperty('--end-x', `${endX - x}px`);
        particle.style.setProperty('--end-y', `${endY - y}px`);
        particle.style.animation = `particleBurst .8s ease-out forwards`;
        particle.style.transform = `translate(${endX - x}px, ${endY - y}px)`;
        
        particlesContainer.appendChild(particle);
        setTimeout(() => particle.remove(), 800);
      }
    }

    function screenFlash() {
      const flash = document.createElement('div');
      flash.className = 'screen-flash';
      document.body.appendChild(flash);
      setTimeout(() => flash.remove(), 400);
    }

    function showNearMiss(message) {
      const msg = document.createElement('div');
      msg.className = 'near-miss-msg';
      msg.textContent = message;
      gameArea.appendChild(msg);
      setTimeout(() => msg.remove(), 800);
    }

    function spawnConfetti(count = 50) {
      const colors = ['#e74c3c', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6', '#e67e22'];
      for (let i = 0; i < count; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = `${Math.random() * 100}vw`;
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDelay = `${Math.random() * 0.5}s`;
        confetti.style.animationDuration = `${2 + Math.random() * 2}s`;
        document.body.appendChild(confetti);
        setTimeout(() => confetti.remove(), 4000);
      }
    }

    function updateComboDisplay() {
      if (currentStreak >= 2) {
        comboMultiplier = currentStreak >= 10 ? 4 : currentStreak >= 5 ? 3 : 2;
        comboDisplay.classList.add('active');
        comboValEl.textContent = `x${comboMultiplier}`;
      } else {
        comboMultiplier = 1;
        comboDisplay.classList.remove('active');
      }
    }

    function updateSpeedIndicator() {
      if (!isSessionActive || isPaused || !dropStartTime) {
        speedIndicator.classList.remove('visible');
        return;
      }
      
      const elapsed = Date.now() - dropStartTime;
      speedIndicator.classList.add('visible');
      
      if (elapsed < SPEED_FAST) {
        speedDot.className = 'speed-dot fast';
        speedText.textContent = 'Quick!';
      } else if (elapsed < SPEED_MEDIUM) {
        speedDot.className = 'speed-dot medium';
        speedText.textContent = 'Good';
      } else {
        speedDot.className = 'speed-dot slow';
        speedText.textContent = 'Take your time';
      }
    }

    // ========= Session Management =========
    function startSession(){
      const minutes = Math.max(1, Math.min(10, parseInt(sessionDurationInput?.value || '2', 10) || 2));
      sessionDuration = minutes * 60 * 1000;
      timeRemaining = sessionDuration;
      score = 0; successfulDrops = 0; totalDrops = 0; totalDropTime = 0; currentRound = 1;
      currentStreak = 0; bestStreak = 0; comboMultiplier = 1;
      maxRounds = Math.max(1, Math.floor(timeRemaining / 6000));
      updateHUD();
      updateComboDisplay();

      isSessionActive = true; isPaused = false;
      if (pauseHudBtn) pauseHudBtn.textContent = '‚è∏';
      if (completionModal) completionModal.style.display='none';
      if (pauseOverlay) pauseOverlay.classList.remove('visible');

      toImmersive();
      
      // Wait for layout to settle before measuring and creating elements
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          const __hud = document.querySelector('.hud');
          const __hudH = __hud ? Math.ceil(__hud.getBoundingClientRect().height) : 0;
          if (gameArea) gameArea.style.paddingTop = (__hudH + 12) + 'px';

          clearGameElements();
          createRound();
          roundStartTime = Date.now();
          dropStartTime = Date.now();
        });
      });

      clearInterval(timerInterval);
      clearInterval(parityInterval);
      clearInterval(speedUpdateInterval);
      
      parityInterval = setInterval(() => { if(isSessionActive && !isPaused){ ensureParity(); } }, 2000);
      speedUpdateInterval = setInterval(updateSpeedIndicator, 100);
      timerInterval = setInterval(() => {
        if(!isPaused){
          timeRemaining -= 100;
          updateTimeUI();
          if (timeRemaining <= 0){ finishSession(); }
        }
      }, 100);
    }

    function togglePause(){
      if(!isSessionActive) return;
      isPaused = !isPaused;
      if (pauseHudBtn) pauseHudBtn.textContent = isPaused ? '‚ñ∂' : '‚è∏';
      if (pauseOverlay) pauseOverlay.classList.toggle('visible', isPaused);
      if (statusMessage) statusMessage.style.opacity = isPaused ? '0' : '1';
      speedIndicator.classList.toggle('visible', !isPaused);
    }

    function restartSession(){
      fromImmersive();
      clearInterval(timerInterval);
      clearInterval(parityInterval);
      clearInterval(speedUpdateInterval);
      isSessionActive=false; isPaused=false;
      timeRemaining = 0; updateTimeUI();
      clearGameElements();
      if (pauseOverlay) pauseOverlay.classList.remove('visible');
      speedIndicator.classList.remove('visible');
    }

    function finishSession(){
      clearInterval(timerInterval);
      clearInterval(parityInterval);
      clearInterval(speedUpdateInterval);
      isSessionActive = false; isPaused = false;
      clearGameElements();
      speedIndicator.classList.remove('visible');

      const accuracy = totalDrops > 0 ? Math.round((successfulDrops / totalDrops) * 100) : 0;
      const avgDropTime = successfulDrops > 0 ? (totalDropTime / successfulDrops / 1000).toFixed(2) : '0.00';

      // Save best streak
      saveBestStreak(bestStreak);
      updateBestStreakDisplay();

      // Check for new PB
      let isNewPB = false;
      try {
        const currentDifficulty = difficultySelect ? difficultySelect.value : 'easy';
        const oldPB = sessionEnhancement.personalBest.getBest(EXERCISE_ID, currentDifficulty);
        isNewPB = score > oldPB;
      } catch(e) {
        const PB_KEY = 'pb:'+EXERCISE_ID;
        const oldPB = Number(localStorage.getItem(PB_KEY) || 0);
        isNewPB = score > oldPB;
      }

      try { sessionEnhancement.handleSessionComplete({ score, drops: successfulDrops, accuracy, avgDropTime: Number(avgDropTime) }); } catch(e){}

      const difficulty = difficultySelect ? difficultySelect.value : 'easy';
      try { recordSession(EXERCISE_ID, difficulty, score); } catch(e){}
      
      let unlockedAchievements = [];
      try {
        markExerciseTried(EXERCISE_ID);
        unlockedAchievements = checkAndUnlockAchievements() || [];
        if (Array.isArray(unlockedAchievements) && unlockedAchievements.length && typeof window.showAchievementNotification === 'function') {
          unlockedAchievements.forEach(id => window.showAchievementNotification(id));
        }
      } catch(e) {}

      updatePersonalBestDisplay();

      // Calculate XP
      const base = Math.round(score / 10);
      const accBonus = Math.round(base * ( (totalDrops>0?successfulDrops/totalDrops:0) ) * 0.2);
      const streakBonus = Math.round(bestStreak * 5);
      const diffMult = (difficulty === 'hard' ? 1.4 : difficulty === 'medium' ? 1.2 : 1.0);
      const xp = Math.max(0, Math.round((base + accBonus + streakBonus) * diffMult));

      // Update completion UI
      if (finalScoreEl) finalScoreEl.textContent = String(score);
      if (finalDropsEl) finalDropsEl.textContent = String(successfulDrops);
      if (finalAccuracyEl) finalAccuracyEl.textContent = `${accuracy}%`;
      if (finalAvgTimeEl) finalAvgTimeEl.textContent = `${avgDropTime}s`;
      if (finalBestComboEl) finalBestComboEl.textContent = `x${bestStreak >= 10 ? 4 : bestStreak >= 5 ? 3 : bestStreak >= 2 ? 2 : 1}`;
      if (finalXpEl) finalXpEl.textContent = `+${xp}`;

      // Show new PB badge and confetti
      if (newPbBadge) newPbBadge.style.display = isNewPB ? 'inline-block' : 'none';
      if (isNewPB) {
        setTimeout(() => spawnConfetti(60), 200);
      }

      // Show achievements
      if (achievementsSection && achievementsList) {
        if (unlockedAchievements.length > 0) {
          achievementsSection.style.display = 'block';
          achievementsList.innerHTML = unlockedAchievements.map(a => 
            `<span class="achievement-badge">üèÜ ${a}</span>`
          ).join('');
        } else {
          achievementsSection.style.display = 'none';
        }
      }

      if (completionModal) completionModal.style.display='grid';
      requestAnimationFrame(() => completionCard && completionCard.focus());
      fromImmersive();
    }

    function updateHUD(){
      if (scoreEl) scoreEl.textContent = String(score);
      if (roundNumber) roundNumber.textContent = String(currentRound);
      if (totalRounds) totalRounds.textContent = String(maxRounds);
      updateTimeUI();
    }

    function clearGameElements(){
      activeDroppables.forEach(d => d.remove());
      activeTargets.forEach(t => t.remove());
      activeDroppables = []; activeTargets = [];
    }

    function createRound(){
      clearGameElements();
      const diff = DIFF[difficultySelect?.value || 'easy'] || DIFF.easy;
      const numTargets = parseInt(numTargetsSelect?.value || '1', 10) || 1;
      const showNumbers = (showNumbersSelect?.value || 'no') === 'yes';
      const showShapes = (showShapesSelect?.value || 'no') === 'yes';

      const gameRect = gameArea.getBoundingClientRect();
      const positions = [];

      // Targets
      for(let i=0;i<numTargets;i++){
        const t = document.createElement('div');
        t.className = 'target'; t.dataset.targetId = String(i);
        const col = palette[i % palette.length];
        t.style.borderColor = col.solid;
        t.style.color = col.solid;
        t.style.width = `${diff.targetSize}px`; t.style.height = `${diff.targetSize}px`;

        const pos = findOpenPos(diff.targetSize, positions, gameRect, diff.spacing);
        positions.push(pos);
        t.style.left = `${pos.x}px`; t.style.top = `${pos.y}px`;

        // Content container
        const content = document.createElement('div');
        content.style.cssText = 'display:flex;flex-direction:column;align-items:center;gap:2px;';
        
        if (showShapes) {
          const shape = document.createElement('div');
          shape.style.cssText = 'font-size:16px;opacity:0.7;';
          shape.style.color = col.solid;
          shape.textContent = col.shape;
          content.appendChild(shape);
        }
        if (showNumbers){
          const n = document.createElement('div');
          n.style.cssText = 'font-weight:800;font-size:14px;';
          n.style.color = col.solid;
          n.textContent = String(i+1);
          content.appendChild(n);
        }
        if (content.children.length > 0) t.appendChild(content);
        
        gameArea.appendChild(t); activeTargets.push(t);
      }

      // Draggables
      for(let i=0;i<numTargets;i++){
        const d = document.createElement('div');
        d.className = 'draggable';
        d.dataset.targetId = String(i);
        const col = palette[i % palette.length];
        d.style.width = `${diff.objectSize}px`; d.style.height = `${diff.objectSize}px`;
        d.style.background = col.grad; d.style.boxShadow = `0 4px 15px ${col.solid}66`;
        
        // Calculate and validate position
        const B = getPlayableRect();
        let ballX = randomEdgeX(gameRect, diff.objectSize);
        let ballY = randomEdgeY(gameRect, diff.objectSize);
        
        // Ensure ball is within visible bounds
        ballX = Math.max(B.minX, Math.min(B.maxX - diff.objectSize, ballX));
        ballY = Math.max(B.minY, Math.min(B.maxY - diff.objectSize, ballY));
        
        d.style.left = `${ballX}px`;
        d.style.top = `${ballY}px`;
        d.setAttribute('tabindex','0');
        
        // Content
        const contentWrapper = document.createElement('div');
        contentWrapper.style.cssText = 'display:flex;flex-direction:column;align-items:center;gap:1px;';
        
        if (showShapes) {
          const shape = document.createElement('div');
          shape.style.cssText = 'font-size:12px;opacity:0.9;text-shadow:0 1px 2px rgba(0,0,0,.5);';
          shape.textContent = col.shape;
          contentWrapper.appendChild(shape);
        }
        if (showNumbers) {
          const num = document.createElement('div');
          num.style.cssText = 'font-weight:800;font-size:12px;';
          num.textContent = String(i+1);
          contentWrapper.appendChild(num);
        }
        if (contentWrapper.children.length > 0) d.appendChild(contentWrapper);
        
        addDragListeners(d);
        gameArea.appendChild(d); activeDroppables.push(d);
      }

      if (statusMessage) statusMessage.textContent = numTargets > 1 ? 'Match each object to its target' : 'Drag to the target';
      roundStartTime = Date.now();
      dropStartTime = Date.now();
      updateHUD();
      ensureParity();
    }

    function randomEdgeX(rect, size){
      const B = getPlayableRect();
      const safeWidth = Math.max(size + 40, B.maxX - B.minX - size);
      // Spawn in left or right third of the screen
      const useRight = Math.random() > 0.5;
      if (useRight) {
        return Math.min(B.maxX - size - 10, B.minX + safeWidth * 0.7 + Math.random() * safeWidth * 0.25);
      }
      return Math.max(B.minX + 10, B.minX + Math.random() * safeWidth * 0.25);
    }
    function randomEdgeY(rect, size){
      const B = getPlayableRect();
      const safeHeight = Math.max(size + 40, B.maxY - B.minY - size);
      // Spawn in top or bottom third (avoiding middle where targets usually are)
      const useBottom = Math.random() > 0.5;
      if (useBottom) {
        return Math.min(B.maxY - size - 10, B.minY + safeHeight * 0.7 + Math.random() * safeHeight * 0.25);
      }
      return Math.max(B.minY + 10, B.minY + Math.random() * safeHeight * 0.25);
    }

    function findOpenPos(size, taken, rect, spacing){
      const B = getPlayableRect();
      const pad = 12; 
      const max = 100;
      for (let a=0; a<max; a++){
        const x = B.minX + pad + Math.random()*Math.max(0, (B.maxX - size) - (B.minX + pad));
        const y = B.minY + pad + Math.random()*Math.max(0, (B.maxY - size) - (B.minY + pad));
        let clash = false;
        for (const p of taken){
          if (dist(x+size/2,y+size/2,p.x+p.size/2,p.y+p.size/2) < (size/2 + p.size/2 + spacing)){ clash = true; break; }
        }
        if (!clash) return { x, y, size };
      }
      return {
        x: Math.max(B.minX + pad, Math.min(B.maxX - size - pad, (B.minX + B.maxX - size)/2)),
        y: Math.max(B.minY + pad, Math.min(B.maxY - size - pad, (B.minY + B.maxY - size)/2)),
        size
      };
    }
    function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }

    // === Parity watchdog ===
    function ensureParity() {
      const targetIds = new Set(activeTargets.map(t => String(t.dataset.targetId)));
      const ballIds = new Set(activeDroppables.map(d => String(d.dataset.targetId)));

      const missing = [...targetIds].filter(id => !ballIds.has(id));
      if (missing.length) {
        const diff = DIFF[difficultySelect?.value || 'easy'] || DIFF.easy;
        const gameRect = gameArea.getBoundingClientRect();
        const showNumbers = (showNumbersSelect?.value || 'no') === 'yes';
        const showShapes = (showShapesSelect?.value || 'no') === 'yes';
        
        missing.forEach(id => {
          const i = parseInt(id, 10) || 0;
          const d = document.createElement('div');
          d.className = 'draggable';
          d.dataset.targetId = id;
          const col = palette[i % palette.length];
          d.style.width = `${diff.objectSize}px`; d.style.height = `${diff.objectSize}px`;
          d.style.background = col.grad; d.style.boxShadow = `0 4px 15px ${col.solid}66`;
          
          // Calculate and validate position
          const B = getPlayableRect();
          let ballX = randomEdgeX(gameRect, diff.objectSize);
          let ballY = randomEdgeY(gameRect, diff.objectSize);
          ballX = Math.max(B.minX, Math.min(B.maxX - diff.objectSize, ballX));
          ballY = Math.max(B.minY, Math.min(B.maxY - diff.objectSize, ballY));
          
          d.style.left = `${ballX}px`;
          d.style.top = `${ballY}px`;
          d.setAttribute('tabindex','0');
          
          const contentWrapper = document.createElement('div');
          contentWrapper.style.cssText = 'display:flex;flex-direction:column;align-items:center;gap:1px;';
          if (showShapes) {
            const shape = document.createElement('div');
            shape.style.cssText = 'font-size:12px;opacity:0.9;';
            shape.textContent = col.shape;
            contentWrapper.appendChild(shape);
          }
          if (showNumbers) {
            const num = document.createElement('div');
            num.style.cssText = 'font-weight:800;font-size:12px;';
            num.textContent = String(i+1);
            contentWrapper.appendChild(num);
          }
          if (contentWrapper.children.length > 0) d.appendChild(contentWrapper);
          
          addDragListeners(d);
          gameArea.appendChild(d); activeDroppables.push(d);
        });
      }
    }

    function addDragListeners(el){
      el.addEventListener('mousedown', startDrag);
      el.addEventListener('touchstart', startDrag, { passive:false });
    }
    function startDrag(e){
      if (!isSessionActive || isPaused) return;
      e.preventDefault();
      currentDragging = e.currentTarget;
      currentDragging.classList.add('dragging');

      const r = currentDragging.getBoundingClientRect();
      const rect = gameArea.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      dragOffsetX = clientX - r.left;
      dragOffsetY = clientY - r.top;

      document.addEventListener('mousemove', onDrag, { passive:false });
      document.addEventListener('touchmove', onDrag, { passive:false });
      document.addEventListener('mouseup', endDrag, { passive:false, once:true });
      document.addEventListener('touchend', endDrag, { passive:false, once:true });
    }
    function onDrag(e){
      if (!currentDragging) return;
      e.preventDefault();
      const rect = gameArea.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;

      let x = clientX - rect.left - dragOffsetX;
      let y = clientY - rect.top - dragOffsetY;
      x = Math.max(0, Math.min(rect.width - currentDragging.offsetWidth, x));
      y = Math.max(0, Math.min(rect.height - currentDragging.offsetHeight, y));
      const __B = getPlayableRect();
      y = Math.max(__B.minY, Math.min(__B.maxY - currentDragging.offsetHeight, y));
      x = Math.max(__B.minX, Math.min(__B.maxX - currentDragging.offsetWidth, x));

      currentDragging.style.left = `${x}px`;
      currentDragging.style.top = `${y}px`;

      checkProximity();
    }
    function endDrag(){
      if (!currentDragging) return;
      checkDrop();
      currentDragging.classList.remove('dragging');
      currentDragging = null;
      document.removeEventListener('mousemove', onDrag);
      document.removeEventListener('touchmove', onDrag);
    }

    function checkProximity(){
      for(const t of activeTargets){ t.classList.remove('active'); }
      if (!currentDragging) return;
      const dRect = currentDragging.getBoundingClientRect();
      const dCx = dRect.left + dRect.width/2;
      const dCy = dRect.top + dRect.height/2;
      for(const t of activeTargets){
        const tRect = t.getBoundingClientRect();
        const tCx = tRect.left + tRect.width/2;
        const tCy = tRect.top + tRect.height/2;
        const radius = Math.min(tRect.width, tRect.height)/2;
        const near = Math.hypot(dCx - tCx, dCy - tCy) <= radius * 1.15;
        if (near) t.classList.add('active');
      }
    }

    function checkDrop(){
      if (!currentDragging) return;
      totalDrops++;
      const id = currentDragging.dataset.targetId;
      let matched = false;
      let droppedOnWrongTarget = false;

      // Get drop position for effects
      const dRect = currentDragging.getBoundingClientRect();
      const gameRect = gameArea.getBoundingClientRect();
      const dropX = dRect.left - gameRect.left + dRect.width/2;
      const dropY = dRect.top - gameRect.top;

      // Check all targets
      for (let i=0; i<activeTargets.length; i++){
        const t = activeTargets[i];
        const tRect = t.getBoundingClientRect();
        const dCx = dRect.left + dRect.width/2;
        const dCy = dRect.top + dRect.height/2;
        const tCx = tRect.left + tRect.width/2;
        const tCy = tRect.top + tRect.height/2;
        const radius = Math.min(tRect.width, tRect.height)/2;
        const isOverTarget = Math.hypot(dCx - tCx, dCy - tCy) <= radius * 0.9;
        
        if (isOverTarget) {
          if (t.dataset.targetId === id) {
            // Correct match!
            matched = true;
            const diff = DIFF[difficultySelect?.value || 'easy'] || DIFF.easy;
            const elapsed = Date.now() - dropStartTime;
            totalDropTime += elapsed;
            successfulDrops++;
            currentStreak++;
            if (currentStreak > bestStreak) bestStreak = currentStreak;
            
            // Calculate points with combo
            updateComboDisplay();
            let points = diff.points * comboMultiplier;
            
            // Speed bonus
            let speedBonus = 0;
            if (elapsed < SPEED_FAST) {
              speedBonus = 50;
            } else if (elapsed < SPEED_MEDIUM) {
              speedBonus = 25;
            }
            
            score += points + speedBonus;
            updateHUD();
            
            // Visual & audio feedback
            const col = palette[parseInt(id, 10) % palette.length];
            AudioSystem.play(currentStreak >= 2 ? 'combo' : 'drop');
            AudioSystem.haptic(currentStreak >= 2 ? 100 : 50);
            
            t.classList.add('success');
            createParticles(dropX, dropY, col.solid, currentStreak >= 2 ? 20 : 12);
            
            // Score popup
            let popupText = `+${points}`;
            if (comboMultiplier > 1) {
              popupText = `+${points} x${comboMultiplier}`;
              createScorePopup(dropX, dropY - 30, popupText, 'combo', '#ffd700');
              screenFlash();
            } else {
              createScorePopup(dropX, dropY - 20, popupText, 'normal', col.solid);
            }
            
            // Speed bonus popup
            if (speedBonus > 0) {
              AudioSystem.play('speedBonus');
              setTimeout(() => {
                createScorePopup(dropX + 20, dropY, `+${speedBonus} Quick!`, 'speed-bonus');
              }, 200);
            }
            
            currentDragging.remove();
            t.remove();
            activeDroppables = activeDroppables.filter(el => el !== currentDragging);
            activeTargets = activeTargets.filter(el => el !== t);
            break;
          } else {
            // Wrong target
            droppedOnWrongTarget = true;
            t.classList.add('wrong-hint');
            setTimeout(() => t.classList.remove('wrong-hint'), 400);
          }
        }
      }

      if (!matched) {
        // Missed or wrong target
        currentStreak = 0;
        updateComboDisplay();
        
        if (droppedOnWrongTarget) {
          AudioSystem.play('miss');
          AudioSystem.haptic(30);
          showNearMiss('Wrong colour!');
          
          // Briefly highlight the correct target
          const correctTarget = activeTargets.find(t => t.dataset.targetId === id);
          if (correctTarget) {
            correctTarget.classList.add('active');
            setTimeout(() => correctTarget.classList.remove('active'), 600);
          }
        }
      }

      ensureParity();
      if (activeDroppables.length === 0 && activeTargets.length === 0){
        currentRound++;
        if (currentRound <= maxRounds){ createRound(); }
        else { finishSession(); }
      } else {
        dropStartTime = Date.now();
      }
    }

    // Global hook
    window.endSession = function(scoreFinal, difficulty = 'easy') {
      try { recordSession(EXERCISE_ID, difficulty, scoreFinal); } catch(e) {}
      try {
        const unlocked = checkAndUnlockAchievements();
        if (Array.isArray(unlocked) && unlocked.length && typeof window.showAchievementNotification === 'function') {
          unlocked.forEach(id => window.showAchievementNotification(id));
        }
      } catch(e) {}
    };
  })();
  </script>
</body>
</html>