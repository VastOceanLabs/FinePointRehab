<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Letter & Number Trace ‚Äì Fine Motor Rehab</title>
  <style>
    :root{
      --vh: 1vh;
      --bg-1:#070b16; --bg-2:#0f1630; --bg-3:#0b1024;
      --accent: #6fd3f5;
      --accent-2: #9ae6ff;
      --gold: #ffd700;
      --radius: 14px;
      --panel: rgba(10,16,36,.9);
      --panel-border: rgba(255,255,255,.08);
      --text: #eaf6ff;
      --text-secondary: #b8c5d1;
      --text-muted: #8a96a3;
      --good: #8ff5b2;
      --warning: #ffd666;
      --error: #ff6b6b;
      --border: #374151;
      --radius-lg: 12px;
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --font-size-xs: 12px;
      --font-size-base: 16px;
      --font-size-lg: 20px;
      --font-size-xl: 24px;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 25%, rgba(70,30,120,.35), transparent 60%),
        radial-gradient(900px 700px at 75% 65%, rgba(20,120,160,.28), transparent 55%),
        linear-gradient(180deg, var(--bg-1) 0%, var(--bg-2) 50%, var(--bg-3) 100%);
      min-height:100vh; touch-action: manipulation; user-select:none; -webkit-user-select:none;
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
      overflow-x:hidden;
    }
    body.playing{ overflow:hidden; }
    body.playing header.app{ display:none; }

    header.app{
      position:sticky; top:0; z-index:50;
      padding:12px 16px; display:flex; gap:12px; align-items:center;
      background: linear-gradient(180deg, rgba(8,12,26,.9), rgba(8,12,26,.55));
      border-bottom: 1px solid rgba(255,255,255,.06);
      backdrop-filter: blur(6px);
    }
    header .home{
      text-decoration:none; color:var(--text); font-weight:700;
      border:1px solid rgba(255,255,255,.18); border-radius:999px; padding:8px 12px;
      transition:.2s;
    }
    header .home:hover{ background: rgba(111,211,245,.12); border-color:var(--accent); }
    header h1{ margin:0; font-size:clamp(18px,3vw,24px); }

    .layout{
      display:grid; grid-template-columns:400px 1fr;
      gap:20px; padding:20px; max-width:1800px; margin:0 auto;
      min-height: calc(100vh - 60px); align-items:start;
    }
    .panel{
      background:var(--panel); border:1px solid var(--panel-border);
      border-radius:var(--radius); box-shadow:0 10px 40px rgba(0,0,0,.35); padding:20px;
    }
    .panel h2{ margin:0 0 16px; font-size:var(--font-size-lg); text-align:center; }
    .desc{
      margin-bottom:16px; background: rgba(111,211,245,.08);
      border-left:4px solid rgba(111,211,245,.7); padding:12px; border-radius:8px;
      font-size:14px; line-height:1.5;
    }
    .kbd-hint{
      margin-top:8px; padding:8px; background:rgba(111,211,245,.05);
      border-radius:6px; font-size:12px; color:var(--text-secondary);
    }
    .kbd{ 
      display:inline-block; padding:2px 6px; background:rgba(111,211,245,.15);
      border-radius:4px; font-family:monospace; font-weight:600;
      border:1px solid rgba(111,211,245,.3);
    }
    .stats-row{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-bottom:16px; }
    .metric{
      flex:1 1 auto; display:flex; flex-direction:column; align-items:center; justify-content:center;
      text-align:center; padding:12px; border:1px solid rgba(255,255,255,.12);
      border-radius:12px; background: rgba(111,211,245,.08); min-width:110px;
    }
    .v{ font-weight:900; font-size:24px; color:#bfe6ff; text-shadow:0 0 6px rgba(150,220,255,.5); line-height:1.1; }
    .t{ font-size:12px; opacity:.9; margin-top:4px; color:var(--text-secondary); }

    .group{ margin-bottom:16px; }
    .label{ display:block; margin-bottom:8px; font-weight:700; letter-spacing:.2px; }
    select,input[type="number"]{
      width:100%; padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,.2);
      background: rgba(5,10,26,.8); color:var(--text); font-size:16px;
    }
    select:focus,input[type="number"]:focus{
      outline:none; border-color: rgba(111,211,245,.9); box-shadow:0 0 0 2px rgba(111,211,245,.25);
    }
    .btn{
      width:100%; min-height:50px; border:1px solid rgba(111,211,245,.35);
      background: rgba(111,211,245,.12); color:var(--text); border-radius:10px; font-weight:800;
      letter-spacing:.2px; cursor:pointer; transition:.2s; font-size:16px;
    }
    .btn:hover:not(:disabled){ background:rgba(111,211,245,.22); transform:translateY(-1px); }
    .btn:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }
    .btn-primary{ background: rgba(111,211,245,.95); color:#07101e; border-color: rgba(111,211,245,1); }
    .btn-primary:hover:not(:disabled){ background: rgba(111,211,245,1); box-shadow:0 6px 18px rgba(111,211,245,.45); }
    .btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,.15); padding:8px 16px; min-height:44px; width:auto; }

    #gameCol{ display:none; position:relative; padding:0; overflow:hidden; height: calc(100vh - 100px); }
    body.playing #gameCol{
      display:flex; flex-direction:column; position:fixed; inset:0; width:100vw; height:100vh; z-index:100;
    }
    body.playing #settings{ display:none; }

    .hud{
      display:grid; grid-template-columns:repeat(5,1fr); gap:var(--space-3); align-items:center;
      position:relative; padding:var(--space-4); padding-top:calc(var(--space-4) + 8px);
      background:rgba(15,22,41,.85); backdrop-filter:blur(12px);
      border-bottom:1px solid var(--border); box-shadow:0 4px 20px rgba(0,0,0,.3); flex-shrink:0;
    }
    .timer-bar{ position:absolute; top:0; left:0; height:8px; width:100%;
      background:linear-gradient(90deg,var(--accent),rgba(111,211,245,.35)); transform-origin:left center; transition:width .1s linear;
    }
    .hud-group{ display:grid; gap:var(--space-1); text-align:center; }
    .hud-value{ font-size:28px; font-weight:var(--font-weight-bold); color:var(--accent); text-shadow:0 0 8px rgba(111,211,245,.7); }
    .hud-label{ font-size:13px; color:var(--text-secondary); opacity:.9; }
    .controls{ display:flex; gap:var(--space-3); justify-content:center; grid-column:1/-1; margin-top:var(--space-2); }

    #game-container{ position:relative; flex:1; display:flex; flex-direction:column; min-height:0; background:rgba(0,0,0,.2); overflow:hidden; }
    #stars-container{ position:absolute; inset:0; pointer-events:none; z-index:1; }
    #particles-container{ position:absolute; inset:0; pointer-events:none; z-index:10; }

    .trace-area{ position:relative; flex:1; display:flex; align-items:center; justify-content:center; min-height:0; padding:20px; }

    #trace-canvas{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      cursor:crosshair; touch-action:none; background:rgba(0,0,0,.2); border-radius:12px;
    }

    .instruction{
      position:absolute; top:20px; left:50%; transform:translateX(-50%);
      background:rgba(10,16,36,.9); border:1px solid rgba(111,211,245,.3); border-radius:12px;
      padding:12px 24px; font-weight:600; font-size:18px; z-index:3; text-align:center; color:var(--accent);
    }
    .char-label{
      position:absolute; top:80px; left:50%; transform:translateX(-50%); font-size:48px; font-weight:900;
      color:var(--text); text-shadow:0 0 20px rgba(111,211,245,.6); z-index:3;
    }

    .progress-ring{
      position:absolute; top:140px; left:50%; transform:translateX(-50%);
      width:80px; height:80px; z-index:3;
    }
    .progress-ring circle{
      fill:none; stroke-width:6; transform:rotate(-90deg); transform-origin:50% 50%;
      transition:stroke-dashoffset .3s ease;
    }
    .progress-ring .bg{ stroke:rgba(111,211,245,.2); }
    .progress-ring .fg{ stroke:var(--accent); }
    .progress-text{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      font-size:16px; font-weight:700; color:var(--accent);
    }

    .hint{
      position:absolute; bottom:30px; left:50%; transform:translateX(-50%);
      background:rgba(255,214,102,.15); border:1px solid rgba(255,214,102,.4);
      border-radius:8px; padding:8px 16px; font-size:14px; font-weight:600;
      color:var(--warning); z-index:3; animation:hintPulse 2s ease-in-out infinite;
    }
    @keyframes hintPulse{
      0%,100%{ opacity:.7; transform:translateX(-50%) scale(.98); }
      50%{ opacity:1; transform:translateX(-50%) scale(1); }
    }

    .particle{ position:absolute; width:6px; height:6px; border-radius:50%; pointer-events:none; animation:particleFloat 1s ease-out forwards; }
    @keyframes particleFloat{
      from{ opacity:1; transform:translate(-50%,-50%) translateY(0) scale(1); }
      to{ opacity:0; transform:translate(-50%,-50%) translateY(-80px) scale(0.3); }
    }

    .feedback{
      position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      font-size:48px; font-weight:900; pointer-events:none; z-index:11; animation:feedbackAppear 1s ease-out forwards;
    }
    .feedback.perfect{ color:var(--gold); text-shadow:0 0 20px rgba(255,215,0,.9); }
    .feedback.good{ color:var(--good); text-shadow:0 0 20px rgba(143,245,178,.9); }
    .feedback.error{ color:var(--error); text-shadow:0 0 20px rgba(255,107,107,.9); }
    @keyframes feedbackAppear{
      0%{ opacity:0; transform:translate(-50%,-50%) scale(0.5); }
      20%{ opacity:1; transform:translate(-50%,-50%) scale(1.2); }
      80%{ opacity:1; transform:translate(-50%,-50%) scale(1); }
      100%{ opacity:0; transform:translate(-50%,-50%) scale(0.8); }
    }

    .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:200; background:rgba(0,0,0,.6); backdrop-filter:blur(6px); }
    .modal.open{ display:flex; }
    .modal .card{
      width:min(560px,92vw); border:1px solid rgba(255,255,255,.18); border-radius:14px; background:var(--panel); padding:24px; animation:modalSlideIn .3s ease-out;
    }
    @keyframes modalSlideIn{
      from{ opacity:0; transform:translateY(-20px) scale(.95); }
      to{ opacity:1; transform:translateY(0) scale(1); }
    }

    .tutorial-modal .card{ max-width:500px; }
    .tutorial-step{ margin:16px 0; padding:12px; background:rgba(111,211,245,.08); border-radius:8px; }
    .tutorial-step strong{ color:var(--accent); display:block; margin-bottom:4px; }

    .setting-help{ display:block; color:var(--text-muted); font-size:13px; margin-top:8px; font-style:italic; }
    .error-msg{ color:var(--error); font-size:13px; margin-top:4px; display:none; }
    .error-msg.show{ display:block; }

    @media (max-width:1024px){
      .layout{ grid-template-columns:1fr; padding:16px; gap:16px; }
      #gameCol{ height:auto; min-height:500px; }
    }
    @media (max-width:768px){
      .hud{ grid-template-columns:repeat(3,1fr); gap:var(--space-2); padding:var(--space-3); padding-top:calc(var(--space-3) + 6px); }
      .hud-value{ font-size:20px; }
      .hud-label{ font-size:11px; }
      .controls{ grid-column:1/-1; gap:var(--space-2); margin-top:var(--space-2); }
      .controls .btn{ padding:8px 16px; font-size:14px; min-height:40px; }
      .layout{ padding:12px; }
      .panel{ padding:16px; }
      .feedback{ font-size:32px; }
      .instruction{ font-size:14px; padding:10px 20px; }
      .char-label{ font-size:36px; top:70px; }
      .progress-ring{ top:120px; width:60px; height:60px; }
      .progress-text{ font-size:12px; }
    }
    body:not(.playing) #gameCol{ display:none; }

    @keyframes twinkle{ 0%,100%{opacity:.2; transform:scale(.8);} 50%{opacity:1; transform:scale(1.2);} }
  </style>
</head>
<body>
  <header class="app" role="banner">
    <a class="home" href="/" aria-label="Back to Home">‚Üê Home</a>
    <h1>Letter & Number Trace</h1>
  </header>

  <main class="layout">
    <aside id="settings" class="panel">
      <h2>Settings</h2>
      <div class="desc">
        <strong>How to play:</strong> Trace the letter or number following the guide. It will automatically complete when you've traced enough! Use "Clear" to start over.
        <div class="kbd-hint">
          <strong>Keyboard shortcuts:</strong><br>
          <kbd>Space</kbd> Pause/Resume ‚Ä¢ <kbd>C</kbd> Clear ‚Ä¢ <kbd>N</kbd> Next ‚Ä¢ <kbd>Esc</kbd> Exit
        </div>
      </div>

      <div class="stats-row">
        <div class="metric"><div id="pbSettings" class="v" aria-live="polite">0</div><div class="t">Personal Best</div></div>
      </div>

      <div class="group">
        <label class="label" for="dur">Session Duration (minutes)</label>
        <input id="dur" type="number" min="0.5" step="0.5" max="10" value="2" inputmode="decimal" aria-describedby="dur-help dur-error" />
        <small id="dur-help" class="setting-help">0.5‚Äì10 minutes recommended for motor training.</small>
        <small id="dur-error" class="error-msg" role="alert">Please enter a value between 0.5 and 10</small>
      </div>

      <div class="group">
        <label class="label" for="mode">Trace Mode</label>
        <select id="mode" aria-label="Select trace mode">
          <option value="uppercase" selected>Uppercase Letters (A-Z)</option>
          <option value="lowercase">Lowercase Letters (a-z)</option>
          <option value="numbers">Numbers (0-9)</option>
        </select>
      </div>

      <div class="group">
        <label class="label" for="size">Letter Size</label>
        <select id="size" aria-label="Select letter size">
          <option value="large">Large</option>
          <option value="medium" selected>Medium</option>
          <option value="small">Small</option>
        </select>
        <small class="setting-help">Size of the letters/numbers on screen.</small>
      </div>

      <div class="group">
        <label class="label" for="difficulty">Border Width (Difficulty)</label>
        <select id="difficulty" aria-label="Select difficulty level">
          <option value="easy">Easy (Thick borders)</option>
          <option value="medium" selected>Medium (Normal borders)</option>
          <option value="hard">Hard (Thin borders)</option>
        </select>
        <small class="setting-help">Thinner borders require more precision.</small>
      </div>

      <button id="tutorialBtn" class="btn btn-ghost" type="button" style="margin-bottom:12px;">Show Tutorial</button>
      <button id="startBtn" class="btn btn-primary" type="button">Start Session</button>
    </aside>

    <section id="gameCol" class="right-col" role="main">
      <div class="hud">
        <div class="timer-bar" id="timer-bar"></div>
        <div class="hud-group"><div id="score" class="hud-value" aria-live="polite" aria-atomic="true">0</div><div class="hud-label">Score</div></div>
        <div class="hud-group"><div id="completed" class="hud-value" aria-live="polite" aria-atomic="true">0</div><div class="hud-label">Completed</div></div>
        <div class="hud-group"><div id="accuracy" class="hud-value" aria-live="polite" aria-atomic="true">0%</div><div class="hud-label">Accuracy</div></div>
        <div class="hud-group"><div id="progress" class="hud-value" aria-live="polite" aria-atomic="true">0%</div><div class="hud-label">Progress</div></div>
        <div class="hud-group"><div id="time" class="hud-value" aria-live="polite" aria-atomic="true">00:00</div><div class="hud-label">Time Left</div></div>
        <div class="controls">
          <button id="pauseBtn" class="btn btn-ghost" type="button" aria-label="Pause session">Pause</button>
          <button id="undoBtn" class="btn btn-ghost" type="button" aria-label="Undo last stroke">Undo</button>
          <button id="clearBtn" class="btn btn-ghost" type="button" aria-label="Clear current trace">Clear</button>
          <button id="skipBtn" class="btn btn-ghost" type="button" aria-label="Skip to next character">Skip</button>
          <button id="exitBtn" class="btn btn-ghost" type="button" aria-label="Exit to settings">Exit</button>
        </div>
      </div>

      <div id="game-container">
        <div id="stars-container" aria-hidden="true"></div>
        <div id="particles-container" aria-hidden="true"></div>
        <div class="trace-area">
          <div class="instruction" id="instruction" role="status" aria-live="polite">Trace the letter</div>
          <div class="char-label" id="char-label" aria-label="Current character">A</div>
          <svg class="progress-ring" id="progress-ring" aria-hidden="true">
            <circle class="bg" cx="40" cy="40" r="34" />
            <circle class="fg" cx="40" cy="40" r="34" id="progress-circle" />
            <text class="progress-text" x="40" y="40" text-anchor="middle" dominant-baseline="middle" id="progress-percent">0%</text>
          </svg>
          <div class="hint" id="hint" role="status" aria-live="polite" style="display:none;">Keep going! Almost there!</div>
          <canvas id="trace-canvas" aria-label="Tracing canvas"></canvas>
        </div>
      </div>
    </section>
  </main>

  <!-- Tutorial Modal -->
  <div id="tutorial" class="modal tutorial-modal" role="dialog" aria-modal="true" aria-labelledby="tutorial-title">
    <div class="card">
      <h2 id="tutorial-title" style="margin:0 0 16px 0;">Welcome to Letter & Number Trace! ‚ú®</h2>
      <p>This fine motor rehabilitation tool helps you practice precision tracing.</p>
      
      <div class="tutorial-step">
        <strong>1. Trace the Guide</strong>
        Follow the blue outline with your mouse or finger. Stay within the borders for best accuracy!
      </div>
      
      <div class="tutorial-step">
        <strong>2. Watch Your Progress</strong>
        The progress ring shows how much you've completed. It will auto-advance when done!
      </div>
      
      <div class="tutorial-step">
        <strong>3. Use Shortcuts</strong>
        Press <kbd>Space</kbd> to pause, <kbd>C</kbd> to clear, <kbd>N</kbd> to skip, <kbd>Esc</kbd> to exit
      </div>
      
      <div class="tutorial-step">
        <strong>4. Build Your Score</strong>
        Better accuracy = higher score! Perfect traces earn bonus points!
      </div>
      
      <button id="closeTutorial" class="btn btn-primary" type="button" autofocus>Got it! Let's Start</button>
    </div>
  </div>

  <!-- Done Modal -->
  <div id="done" class="modal" role="dialog" aria-modal="true" aria-labelledby="done-title">
    <div class="card">
      <h2 id="done-title" style="margin:0 0 8px 0;">Session Complete! üéâ</h2>
      <p style="margin:0 0 12px 0;">Excellent work! Here are your results:</p>
      <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px;">
        <div class="metric"><div id="fScore" class="v">0</div><div class="t">Score</div></div>
        <div class="metric"><div id="fCompleted" class="v">0</div><div class="t">Completed</div></div>
        <div class="metric"><div id="fAccuracy" class="v">0%</div><div class="t">Avg Accuracy</div></div>
        <div class="metric"><div id="fPerfect" class="v">0</div><div class="t">Perfect Traces</div></div>
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="newSession" class="btn btn-primary" type="button" autofocus>Start New Session</button>
        <a class="btn btn-ghost" href="/">Home</a>
      </div>
    </div>
  </div>

  <script type="module">
    // ============================
    // CONSTANTS
    // ============================
    const CONSTANTS = {
      MIN_POINTS_FOR_CHECK: 10,
      AUTO_ADVANCE_DELAY: 800,
      PARTICLE_COUNT_PERFECT: 16,
      PARTICLE_COUNT_GOOD: 10,
      ENCOURAGE_THRESHOLD: 70,
      CHECK_INTERVAL: 10,
      UNDO_HISTORY_SIZE: 5,
      STORAGE_KEY_PREFIX: 'PB_',
      EXERCISE_ID: 'letter_number_trace',
      MIN_DURATION: 0.5,
      MAX_DURATION: 10,
      STAR_COUNT: 200
    };

    const SIZE_MAP = { large: 1.5, medium: 1, small: 0.65 };
    const DIFFICULTY_MAP = {
      easy:   { borderWidth: 25, tolerance: 40, minAccuracy: 85 },
      medium: { borderWidth: 20, tolerance: 30, minAccuracy: 90 },
      hard:   { borderWidth: 15, tolerance: 20, minAccuracy: 95 }
    };

    // ============================
    // DOM ELEMENTS
    // ============================
    const $ = s => document.querySelector(s);
    const canvas = $('#trace-canvas');
    const ctx = canvas.getContext('2d');
    const charLabel = $('#char-label');
    const instruction = $('#instruction');
    const scoreEl = $('#score');
    const completedEl = $('#completed');
    const accuracyEl = $('#accuracy');
    const progressEl = $('#progress');
    const timeEl = $('#time');
    const timerBar = $('#timer-bar');
    const startBtn = $('#startBtn');
    const pauseBtn = $('#pauseBtn');
    const undoBtn = $('#undoBtn');
    const clearBtn = $('#clearBtn');
    const skipBtn = $('#skipBtn');
    const exitBtn = $('#exitBtn');
    const tutorialBtn = $('#tutorialBtn');
    const doneModal = $('#done');
    const tutorialModal = $('#tutorial');
    const pbSettingsEl = $('#pbSettings');
    const particlesContainer = $('#particles-container');
    const starsContainer = $('#stars-container');
    const hintEl = $('#hint');
    const progressCircle = $('#progress-circle');
    const progressPercent = $('#progress-percent');
    const durIn = $('#dur');
    const durError = $('#dur-error');
    const modeSelect = $('#mode');
    const sizeSelect = $('#size');
    const difficultySelect = $('#difficulty');

    // ============================
    // STROKE DEFINITIONS
    // ============================
    const STROKES = {
      'A': [[[0.2,1],[0.5,0.2],[0.8,1]], [[0.35,0.6],[0.65,0.6]]],
      'B': [[[0.2,0.2],[0.2,1]], [[0.2,0.2],[0.6,0.2],[0.6,0.5],[0.2,0.5]], [[0.2,0.5],[0.65,0.5],[0.65,1],[0.2,1]]],
      'C': [[[0.78,0.30],[0.60,0.22],[0.42,0.22],[0.30,0.30],[0.24,0.48],[0.30,0.70],[0.42,0.78],[0.60,0.78],[0.78,0.70]]],
      'D': [[[0.2,0.2],[0.2,1]], [[0.2,0.2],[0.6,0.3],[0.7,0.6],[0.6,0.9],[0.2,1]]],
      'E': [[[0.7,0.2],[0.2,0.2],[0.2,1],[0.7,1]], [[0.2,0.55],[0.6,0.55]]],
      'F': [[[0.7,0.2],[0.2,0.2],[0.2,1]], [[0.2,0.55],[0.6,0.55]]],
      'G': [[[0.78,0.30],[0.60,0.22],[0.42,0.22],[0.30,0.30],[0.24,0.48],[0.30,0.70],[0.44,0.78],[0.62,0.78],[0.72,0.72],[0.72,0.56],[0.54,0.56]]],
      'H': [[[0.2,0.2],[0.2,1]], [[0.7,0.2],[0.7,1]], [[0.2,0.55],[0.7,0.55]]],
      'I': [[[0.3,0.2],[0.7,0.2]], [[0.5,0.2],[0.5,1]], [[0.3,1],[0.7,1]]],
      'J': [[[0.3,0.2],[0.7,0.2]], [[0.55,0.2],[0.55,0.8],[0.4,0.95],[0.25,0.85]]],
      'K': [[[0.2,0.2],[0.2,1]], [[0.75,0.2],[0.2,0.6]], [[0.35,0.5],[0.75,1]]],
      'L': [[[0.2,0.2],[0.2,1],[0.7,1]]],
      'M': [[[0.15,1],[0.15,0.2],[0.5,0.6],[0.85,0.2],[0.85,1]]],
      'N': [[[0.2,1],[0.2,0.2],[0.75,1],[0.75,0.2]]],
      'O': [[[0.50,0.20],[0.33,0.28],[0.25,0.48],[0.30,0.74],[0.45,0.88],[0.55,0.88],[0.70,0.74],[0.75,0.48],[0.67,0.28],[0.50,0.20]]],
      'P': [[[0.2,1],[0.2,0.2],[0.65,0.2],[0.7,0.4],[0.65,0.55],[0.2,0.55]]],
      'Q': [[[0.50,0.20],[0.33,0.28],[0.25,0.48],[0.30,0.74],[0.45,0.88],[0.55,0.88],[0.70,0.74],[0.75,0.48],[0.67,0.28],[0.50,0.20]], [[0.60,0.75],[0.85,1.05]]],
      'R': [[[0.2,1],[0.2,0.2],[0.65,0.2],[0.7,0.4],[0.65,0.55],[0.2,0.55]], [[0.45,0.55],[0.75,1]]],
      'S': [[[0.70,0.30],[0.58,0.22],[0.42,0.22],[0.30,0.30],[0.28,0.38],[0.34,0.48],[0.50,0.55],[0.64,0.62],[0.72,0.72],[0.68,0.82],[0.56,0.88],[0.40,0.88],[0.28,0.80]]],
      'T': [[[0.2,0.2],[0.8,0.2]], [[0.5,0.2],[0.5,1]]],
      'U': [[[0.20,0.20],[0.20,0.78],[0.30,0.95],[0.70,0.95],[0.80,0.78],[0.80,0.20]]],
      'V': [[[0.15,0.20],[0.50,1.00],[0.85,0.20]]],
      'W': [[[0.10,0.20],[0.25,1.00],[0.50,0.50],[0.75,1.00],[0.90,0.20]]],
      'X': [[[0.2,0.2],[0.8,1]], [[0.8,0.2],[0.2,1]]],
      'Y': [[[0.2,0.2],[0.5,0.55]], [[0.8,0.2],[0.5,0.55],[0.5,1]]],
      'Z': [[[0.2,0.2],[0.8,0.2],[0.2,1],[0.8,1]]],
      'a': [[[0.70,0.50],[0.40,0.40],[0.28,0.58],[0.40,0.90],[0.70,0.90],[0.70,0.40],[0.70,1.00]]],
      'b': [[[0.20,0.10],[0.20,1.00]], [[0.20,0.50],[0.60,0.40],[0.70,0.65],[0.60,0.90],[0.30,0.95]]],
      'c': [[[0.75,0.50],[0.50,0.40],[0.32,0.52],[0.34,0.80],[0.60,0.88],[0.75,0.82]]],
      'd': [[[0.70,0.10],[0.70,1.00]], [[0.70,0.50],[0.45,0.40],[0.30,0.58],[0.42,0.90],[0.70,0.95]]],
      'e': [[[0.28,0.62],[0.68,0.62],[0.70,0.50],[0.48,0.40],[0.32,0.52],[0.36,0.80],[0.62,0.88]]],
      'f': [[[0.65,0.15],[0.50,0.10],[0.40,0.25],[0.40,1.00]], [[0.25,0.40],[0.60,0.40]]],
      'g': [[[0.70,0.40],[0.45,0.40],[0.30,0.58],[0.42,0.90],[0.70,0.90],[0.70,0.40],[0.70,1.15],[0.50,1.25],[0.30,1.15]]],
      'h': [[[0.20,0.10],[0.20,1.00]], [[0.20,0.50],[0.55,0.40],[0.70,0.55],[0.70,1.00]]],
      'i': [[[0.45,0.22],[0.50,0.15]], [[0.45,0.40],[0.45,1.00]]],
      'j': [[[0.50,0.22],[0.55,0.15]], [[0.50,0.40],[0.50,1.15],[0.40,1.25],[0.25,1.20]]],
      'k': [[[0.20,0.10],[0.20,1.00]], [[0.65,0.40],[0.20,0.70]], [[0.35,0.65],[0.65,1.00]]],
      'l': [[[0.45,0.10],[0.45,1.00]]],
      'm': [[[0.15,1.00],[0.15,0.40]], [[0.15,0.50],[0.35,0.40],[0.40,0.55],[0.40,1.00]], [[0.40,0.50],[0.60,0.40],[0.65,0.55],[0.65,1.00]]],
      'n': [[[0.20,1.00],[0.20,0.40]], [[0.20,0.50],[0.55,0.40],[0.70,0.55],[0.70,1.00]]],
      'o': [[[0.50,0.40],[0.35,0.46],[0.28,0.60],[0.34,0.84],[0.50,0.94],[0.66,0.84],[0.72,0.60],[0.65,0.46],[0.50,0.40]]],
      'p': [[[0.20,0.40],[0.20,1.25]], [[0.20,0.50],[0.60,0.40],[0.70,0.65],[0.60,0.90],[0.30,0.95]]],
      'q': [[[0.70,0.40],[0.70,1.25]], [[0.70,0.50],[0.45,0.40],[0.30,0.58],[0.42,0.90],[0.70,0.95]]],
      'r': [[[0.25,1.00],[0.25,0.40]], [[0.25,0.52],[0.50,0.40],[0.70,0.46]]],
      's': [[[0.74,0.48],[0.62,0.42],[0.52,0.40],[0.42,0.44],[0.34,0.50],[0.36,0.56],[0.46,0.62],[0.58,0.66],[0.68,0.74],[0.64,0.84],[0.54,0.90],[0.40,0.90],[0.30,0.84]]],
      't': [[[0.40,0.20],[0.40,0.90],[0.60,0.95]], [[0.25,0.35],[0.60,0.35]]],
      'u': [[[0.25,0.40],[0.25,0.80],[0.35,0.95],[0.65,0.95],[0.70,0.80],[0.70,0.40],[0.70,1.00]]],
      'v': [[[0.20,0.40],[0.50,1.00],[0.80,0.40]]],
      'w': [[[0.15,0.40],[0.30,1.00],[0.50,0.65],[0.70,1.00],[0.85,0.40]]],
      'x': [[[0.25,0.40],[0.75,1.00]], [[0.75,0.40],[0.25,1.00]]],
      'y': [[[0.25,0.40],[0.25,0.80],[0.35,0.95],[0.65,0.95],[0.70,0.80],[0.70,0.40],[0.70,1.15],[0.50,1.25],[0.30,1.15]]],
      'z': [[[0.25,0.40],[0.75,0.40],[0.25,1.00],[0.75,1.00]]],
      // IMPROVED NUMBERS
      '0': [[[0.50,0.20],[0.34,0.30],[0.26,0.48],[0.28,0.72],[0.40,0.90],[0.60,0.90],[0.72,0.72],[0.74,0.48],[0.66,0.30],[0.50,0.20]]],
      '1': [[[0.45,0.30],[0.55,0.20],[0.55,1.00]], [[0.35,1.00],[0.65,1.00]]],
      '2': [[[0.30,0.30],[0.42,0.22],[0.62,0.22],[0.72,0.30],[0.72,0.40],[0.64,0.50],[0.50,0.62],[0.36,0.76],[0.30,0.88],[0.30,0.96],[0.80,0.96]]],
      '3': [[[0.34,0.26],[0.58,0.22],[0.70,0.36],[0.54,0.50]], [[0.54,0.50],[0.70,0.64],[0.60,0.90],[0.34,0.96]]],
      '4': [[[0.65,0.20],[0.30,0.70],[0.78,0.70]], [[0.65,0.20],[0.65,1.00]]],
      '5': [[[0.70,0.24],[0.34,0.24],[0.32,0.50],[0.62,0.52],[0.70,0.70],[0.60,0.92],[0.34,0.96]]],
      '6': [[[0.62,0.26],[0.44,0.22],[0.30,0.40],[0.28,0.70],[0.40,0.90],[0.60,0.90],[0.70,0.74],[0.62,0.60],[0.36,0.60]]],
      '7': [[[0.26,0.22],[0.76,0.22],[0.42,1.00]]],
      '8': [
        [[0.50,0.19],[0.42,0.23],[0.36,0.35],[0.42,0.47],[0.50,0.51],[0.58,0.47],[0.64,0.35],[0.58,0.23],[0.50,0.19]],
        [[0.50,0.50],[0.38,0.56],[0.30,0.72],[0.38,0.88],[0.50,0.94],[0.62,0.88],[0.70,0.72],[0.62,0.56],[0.50,0.50]]
      ],
      '9': [[[0.40,0.96],[0.58,1.00],[0.72,0.80],[0.72,0.46],[0.62,0.28],[0.44,0.26],[0.34,0.42],[0.42,0.60],[0.70,0.60]]]
    };

    // ============================
    // GAME STATE
    // ============================
    let state = {
      isActive: false,
      isPaused: false,
      score: 0,
      completed: 0,
      perfectCount: 0,
      currentChar: '',
      charQueue: [],
      isDrawing: false,
      isCompleting: false,
      drawnPoints: [],
      undoHistory: [],
      sessionDurationMs: 120000,
      timeRemaining: 120000,
      pauseStartTime: 0,
      scale: 1,
      baseBorderWidth: 20,
      baseTolerance: 30,
      baseMinAccuracy: 90,
      borderWidth: 20,
      tolerance: 30,
      minAccuracy: 90,
      rafId: 0,
      prevTs: 0,
      pathLength: 0,
      coveredLength: 0,
      pathSegments: [],
      coveredSegments: new Set(),
      accuracySum: 0,
      accuracyCount: 0,
      DPR: 1,
      CSS_SIZE: 0,
      completionTimer: 0,
      showedEncouragement: false,
      hasVibration: 'vibrate' in navigator
    };

    // ============================
    // AUDIO
    // ============================
    const audio = {
      playTone(freq, duration, vol = 0.1) {
        if (!window.AudioContext && !window.webkitAudioContext) return;
        try {
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.frequency.value = freq;
          gain.gain.value = vol;
          osc.start();
          osc.stop(ctx.currentTime + duration);
        } catch (e) {}
      },
      playSuccess() { this.playTone(523, 0.1); setTimeout(() => this.playTone(659, 0.15), 100); },
      playPerfect() { this.playTone(523, 0.08); setTimeout(() => this.playTone(659, 0.08), 80); setTimeout(() => this.playTone(784, 0.2), 160); },
      playClick() { this.playTone(440, 0.05, 0.05); },
      playError() { this.playTone(200, 0.2, 0.08); }
    };

    // ============================
    // STORAGE
    // ============================
    const storage = {
      get(k, def) {
        try { 
          const val = localStorage.getItem(k);
          return val ? JSON.parse(val) : def;
        } catch { return def; }
      },
      set(k, v) {
        try { 
          localStorage.setItem(k, JSON.stringify(v));
          return true;
        } catch (e) { 
          console.warn('Storage failed:', e);
          return false;
        }
      }
    };

    // ============================
    // UTILS
    // ============================
    const utils = {
      msToClock(ms) {
        const s = Math.max(0, Math.floor(ms / 1000));
        const m = Math.floor(s / 60);
        const r = s % 60;
        return String(m).padStart(2, '0') + ':' + String(r).padStart(2, '0');
      },
      
      validateDuration(val) {
        const num = parseFloat(val);
        if (isNaN(num)) return null;
        return Math.max(CONSTANTS.MIN_DURATION, Math.min(CONSTANTS.MAX_DURATION, num));
      },

      distanceToSegment(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1, dy = y2 - y1, len2 = dx * dx + dy * dy;
        if (!len2) return Math.hypot(px - x1, py - y1);
        let t = ((px - x1) * dx + (py - y1) * dy) / len2;
        t = Math.max(0, Math.min(1, t));
        const qx = x1 + t * dx, qy = y1 + t * dy;
        return Math.hypot(px - qx, py - qy);
      },

      strokePointsToPixels(stroke, size, ox, oy) {
        return stroke.map(([nx, ny]) => ({ x: ox + nx * size, y: oy + ny * size }));
      },

      vibrate(pattern) {
        if (state.hasVibration) {
          try { navigator.vibrate(pattern); } catch (e) {}
        }
      }
    };

    // ============================
    // CANVAS SETUP
    // ============================
    function setupCanvas() {
      const container = canvas.parentElement;
      const rect = container.getBoundingClientRect();
      state.CSS_SIZE = Math.min(rect.width - 40, rect.height - 200, 600);
      state.CSS_SIZE = Math.max(260, state.CSS_SIZE);

      state.DPR = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.round(state.CSS_SIZE * state.DPR);
      canvas.height = Math.round(state.CSS_SIZE * state.DPR);
      canvas.style.width = state.CSS_SIZE + 'px';
      canvas.style.height = state.CSS_SIZE + 'px';

      ctx.setTransform(state.DPR, 0, 0, state.DPR, 0, 0);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
    }

    function clearCanvas() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(state.DPR, 0, 0, state.DPR, 0, 0);
    }

    // ============================
    // DRAWING
    // ============================
    function drawPolyline(points) {
      if (!points.length) return;
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
      ctx.stroke();
    }

    function drawCatmullRom(points) {
      if (points.length < 2) {
        if (points.length === 1) {
          ctx.beginPath();
          ctx.arc(points[0].x, points[0].y, 0.5, 0, Math.PI * 2);
          ctx.stroke();
        }
        return;
      }
      if (points.length === 2) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(points[1].x, points[1].y);
        ctx.stroke();
        return;
      }

      const alpha = 0.5;
      const dist = (p, q) => Math.hypot(q.x - p.x, q.y - p.y);
      const sub = (p, q) => ({ x: p.x - q.x, y: p.y - q.y });
      const mul = (p, s) => ({ x: p.x * s, y: p.y * s });
      const add = (p, q) => ({ x: p.x + q.x, y: p.y + q.y });

      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);

      for (let i = 0; i < points.length - 1; i++) {
        const p0 = i > 0 ? points[i - 1] : points[i];
        const p1 = points[i];
        const p2 = points[i + 1];
        const p3 = i < points.length - 2 ? points[i + 2] : p2;

        const t0 = 0;
        const t1 = t0 + Math.pow(dist(p0, p1), alpha);
        const t2 = t1 + Math.pow(dist(p1, p2), alpha);
        const t3 = t2 + Math.pow(dist(p2, p3), alpha);

        const dt01 = t1 - t0 || 1;
        const dt02 = t2 - t0 || 1;
        const dt12 = t2 - t1 || 1;
        const dt23 = t3 - t2 || 1;
        const dt13 = t3 - t1 || 1;

        const m1 = mul(sub(mul(sub(p2, p1), dt12 / dt02), mul(sub(p1, p0), dt01 / dt02)), 1);
        const m2 = mul(sub(mul(sub(p3, p2), dt23 / dt13), mul(sub(p2, p1), dt12 / dt13)), 1);

        const dt = dt12;
        const c1 = add(p1, mul(m1, dt / 3));
        const c2 = sub(p2, mul(m2, dt / 3));

        ctx.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, p2.x, p2.y);
      }
      ctx.stroke();
    }

    function drawStrokePath() {
      clearCanvas();
      const strokes = STROKES[state.currentChar];
      if (!strokes) return;

      const size = state.CSS_SIZE * 0.7 * state.scale;
      const offsetX = (state.CSS_SIZE - size) / 2;
      const offsetY = (state.CSS_SIZE - size) / 2;

      state.pathLength = 0;
      state.pathSegments = [];
      let segmentId = 0;

      ctx.save();
      ctx.strokeStyle = 'rgba(111,211,245,0.4)';
      ctx.lineWidth = state.borderWidth;
      
      strokes.forEach(stroke => {
        const pts = utils.strokePointsToPixels(stroke, size, offsetX, offsetY);
        
        // IMPROVEMENT 6: Densify polyline for smoother guide
        const dense = [];
        for (let i = 1; i < pts.length; i++) {
          const a = pts[i-1], b = pts[i];
          const segLen = Math.hypot(b.x - a.x, b.y - a.y);
          // IMPROVEMENT 1: Adaptive step size based on tolerance
          const step = Math.max(3, Math.min(6, state.tolerance * 0.5));
          const n = Math.max(1, Math.ceil(segLen / step));
          for (let j = 0; j <= n; j++) {
            const t = j / n;
            dense.push({ x: a.x + (b.x - a.x)*t, y: a.y + (b.y - a.y)*t });
          }
        }
        
        // Draw the densified guide
        drawPolyline(dense);
        
        // Build segments from the same densified points
        for (let i = 1; i < dense.length; i++) {
          const a = dense[i-1], b = dense[i];
          const segLen = Math.hypot(b.x - a.x, b.y - a.y);
          state.pathLength += segLen;
          state.pathSegments.push({
            x1: a.x,
            y1: a.y,
            x2: b.x,
            y2: b.y,
            length: segLen,
            id: segmentId++
          });
        }
      });
      
      ctx.restore();

      state.coveredSegments = new Set();
      state.coveredLength = 0;
      state.showedEncouragement = false;
      updateProgressRing();
    }

    function getCanvasCoords(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function distanceToPath(x, y) {
      // Use the densified guide for distance checks ‚Äì smoother & fairer
      let minDist = Infinity;
      for (let i = 0; i < state.pathSegments.length; i++) {
        const s = state.pathSegments[i];
        const d = utils.distanceToSegment(x, y, s.x1, s.y1, s.x2, s.y2);
        if (d < minDist) minDist = d;
      }
      return minDist;
    }

    // ============================
    // INPUT HANDLERS
    // ============================
    function startDrawing(e) {
      if (!state.isActive || state.isPaused) return;
      state.isDrawing = true;
      state.drawnPoints = [];
      const p = getCanvasCoords(e);
      state.drawnPoints.push(p);
    }

    function draw(e) {
      if (!state.isDrawing || !state.isActive || state.isPaused) return;
      e.preventDefault();

      const p = getCanvasCoords(e);
      state.drawnPoints.push(p);

      ctx.save();
      ctx.strokeStyle = 'rgba(111,211,245,0.9)';
      ctx.lineWidth = 10;

      if (state.drawnPoints.length >= 4) {
        const slice = state.drawnPoints.slice(-4);
        drawCatmullRom(slice);
      } else if (state.drawnPoints.length > 1) {
        const a = state.drawnPoints[state.drawnPoints.length - 2];
        const b = state.drawnPoints[state.drawnPoints.length - 1];
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
      ctx.restore();

      if (state.drawnPoints.length > 0) {
        const c = state.drawnPoints[state.drawnPoints.length - 1];
        
        state.pathSegments.forEach(seg => {
          if (!state.coveredSegments.has(seg.id)) {
            const dist = utils.distanceToSegment(c.x, c.y, seg.x1, seg.y1, seg.x2, seg.y2);
            if (dist < state.tolerance) {
              state.coveredSegments.add(seg.id);
              state.coveredLength += seg.length;
            }
          }
        });

        if (state.drawnPoints.length % CONSTANTS.CHECK_INTERVAL === 0) {
          autoCheckCompletion();
          updateProgressRing();
        }
      }
    }

    function endDrawing() {
      if (!state.isDrawing) return;
      state.isDrawing = false;
      autoCheckCompletion();
    }

    // ============================
    // GAME LOGIC
    // ============================
    function autoCheckCompletion() {
      if (state.drawnPoints.length < CONSTANTS.MIN_POINTS_FOR_CHECK || state.isCompleting) return;
      
      const coverage = Math.min(100, (state.coveredLength / state.pathLength) * 100);

      if (coverage >= CONSTANTS.ENCOURAGE_THRESHOLD && coverage < state.minAccuracy && !state.showedEncouragement) {
        hintEl.style.display = 'block';
        state.showedEncouragement = true;
        setTimeout(() => { hintEl.style.display = 'none'; }, 2000);
      }

      if (coverage >= state.minAccuracy) {
        // IMPROVEMENT 2: Clamp distance to prevent outliers from ruining score
        let totalDist = 0;
        state.drawnPoints.forEach(p => totalDist += distanceToPath(p.x, p.y));
        const avgDist = totalDist / state.drawnPoints.length;
        const avgClamped = Math.min(avgDist, state.tolerance);
        const distanceScore = 100 * (1 - (avgClamped / state.tolerance));
        const finalAccuracy = (coverage * 0.8) + (distanceScore * 0.2);
        
        if (finalAccuracy >= state.minAccuracy) {
          state.isCompleting = true;
          completeStroke(finalAccuracy);
        }
      }
    }

    function saveUndoState() {
      if (state.drawnPoints.length === 0) return;
      state.undoHistory.push([...state.drawnPoints]);
      if (state.undoHistory.length > CONSTANTS.UNDO_HISTORY_SIZE) {
        state.undoHistory.shift();
      }
    }

    function undoLastStroke() {
      if (!state.isActive || state.isPaused || state.undoHistory.length === 0) return;
      
      state.drawnPoints = state.undoHistory.pop() || [];
      
      state.coveredSegments = new Set();
      state.coveredLength = 0;
      
      state.drawnPoints.forEach(p => {
        state.pathSegments.forEach(seg => {
          if (!state.coveredSegments.has(seg.id)) {
            const dist = utils.distanceToSegment(p.x, p.y, seg.x1, seg.y1, seg.x2, seg.y2);
            if (dist < state.tolerance) {
              state.coveredSegments.add(seg.id);
              state.coveredLength += seg.length;
            }
          }
        });
      });
      
      drawStrokePath();
      
      if (state.drawnPoints.length > 0) {
        ctx.save();
        ctx.strokeStyle = 'rgba(111,211,245,0.9)';
        ctx.lineWidth = 10;
        drawCatmullRom(state.drawnPoints);
        ctx.restore();
      }
      
      updateProgressRing();
      audio.playClick();
    }

    function clearDrawing() {
      if (!state.isActive || state.isPaused) return;
      saveUndoState();
      drawStrokePath();
      state.drawnPoints = [];
      state.coveredSegments = new Set();
      state.coveredLength = 0;
      state.showedEncouragement = false;
      hintEl.style.display = 'none';
      updateProgressRing();
      audio.playClick();
    }

    function updateProgressRing() {
      const coverage = Math.min(100, state.pathLength > 0 ? (state.coveredLength / state.pathLength) * 100 : 0);
      progressEl.textContent = Math.round(coverage) + '%';
      progressPercent.textContent = Math.round(coverage) + '%';
      
      const circumference = 2 * Math.PI * 34;
      const offset = circumference - (coverage / 100) * circumference;
      progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
      progressCircle.style.strokeDashoffset = offset;
    }

    function showFeedback(text, type) {
      const el = document.createElement('div');
      el.className = `feedback ${type}`;
      el.textContent = text;
      el.setAttribute('role', 'status');
      el.setAttribute('aria-live', 'assertive');
      particlesContainer.appendChild(el);
      el.addEventListener('animationend', () => el.remove());
    }

    function createParticles(x, y, count, color) {
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = x + 'px';
        particle.style.top = y + 'px';
        particle.style.background = color;
        const angle = (Math.PI * 2 * i) / count;
        const dist = 40 + Math.random() * 40;
        const tx = Math.cos(angle) * dist;
        const ty = Math.sin(angle) * dist;
        particle.style.setProperty('--tx', tx + 'px');
        particle.style.setProperty('--ty', ty + 'px');
        particlesContainer.appendChild(particle);
        particle.addEventListener('animationend', () => particle.remove());
      }
    }

    function completeStroke(accuracy) {
      clearTimeout(state.completionTimer);
      
      const isPerfect = accuracy >= 95;
      let multiplier = 1;
      if (state.scale === 0.65) multiplier *= 1.3;
      else if (state.scale === 1.5) multiplier *= 0.8;
      if (difficultySelect.value === 'hard') multiplier *= 1.5;
      else if (difficultySelect.value === 'easy') multiplier *= 0.8;

      const points = Math.round(accuracy * multiplier);
      state.score += points;
      state.accuracySum += accuracy;
      state.accuracyCount++;
      state.completed++;
      if (isPerfect) state.perfectCount++;

      showFeedback(isPerfect ? 'PERFECT!' : 'GREAT!', isPerfect ? 'perfect' : 'good');
      createParticles(
        state.CSS_SIZE / 2, 
        state.CSS_SIZE / 2, 
        isPerfect ? CONSTANTS.PARTICLE_COUNT_PERFECT : CONSTANTS.PARTICLE_COUNT_GOOD,
        isPerfect ? '#ffd700' : '#8ff5b2'
      );

      if (isPerfect) {
        audio.playPerfect();
        utils.vibrate([50, 50, 100]);
      } else {
        audio.playSuccess();
        utils.vibrate(50);
      }

      hintEl.style.display = 'none';
      drawStrokePath();
      state.completionTimer = setTimeout(nextChar, CONSTANTS.AUTO_ADVANCE_DELAY);
    }

    function nextChar() {
      clearTimeout(state.completionTimer);
      
      if (state.charQueue.length === 0) {
        let list;
        if (modeSelect.value === 'uppercase') list = Object.keys(STROKES).filter(c => c >= 'A' && c <= 'Z');
        else if (modeSelect.value === 'lowercase') list = Object.keys(STROKES).filter(c => c >= 'a' && c <= 'z');
        else list = Object.keys(STROKES).filter(c => c >= '0' && c <= '9');
        state.charQueue = [...list].sort(() => Math.random() - 0.5);
      }

      state.currentChar = state.charQueue.shift();
      charLabel.textContent = state.currentChar;
      instruction.textContent = (state.currentChar >= '0' && state.currentChar <= '9') ? 'Trace the number' : 'Trace the letter';

      // IMPROVEMENT 3: Digit-specific tuning
      const isDigit = state.currentChar >= '0' && state.currentChar <= '9';
      state.borderWidth = state.baseBorderWidth + (isDigit ? 2 : 0);
      state.tolerance = state.baseTolerance + (isDigit ? 5 : 0);
      state.minAccuracy = state.baseMinAccuracy - (isDigit ? 3 : 0);

      // Extra forgiveness for "8" (tight loops are harder)
      if (state.currentChar === '8') {
        state.tolerance += 2;
        state.minAccuracy -= 1;
      }

      state.drawnPoints = [];
      state.undoHistory = [];
      state.coveredSegments = new Set();
      state.coveredLength = 0;
      state.isCompleting = false;
      state.showedEncouragement = false;
      hintEl.style.display = 'none';

      drawStrokePath();
      updateHUD();
    }

    function skipChar() {
      if (!state.isActive || state.isPaused) return;
      clearTimeout(state.completionTimer);
      audio.playClick();
      nextChar();
    }

    // ============================
    // HUD & UI
    // ============================
    function updateHUD() {
      scoreEl.textContent = String(state.score);
      completedEl.textContent = String(state.completed);
      const avgAcc = state.accuracyCount > 0 ? Math.round(state.accuracySum / state.accuracyCount) : 0;
      accuracyEl.textContent = avgAcc + '%';
      timeEl.textContent = utils.msToClock(state.timeRemaining);
      const pb = storage.get(CONSTANTS.STORAGE_KEY_PREFIX + CONSTANTS.EXERCISE_ID, 0) || 0;
      pbSettingsEl.textContent = String(pb);
      if (timerBar && state.sessionDurationMs > 0) {
        const pct = Math.max(0, Math.min(1, state.timeRemaining / state.sessionDurationMs));
        timerBar.style.width = (pct * 100).toFixed(2) + '%';
      }
    }

    // ============================
    // GAME LOOP
    // ============================
    function loop(now) {
      if (!state.isActive) return;
      
      const dt = state.prevTs ? (now - state.prevTs) : 16;
      state.prevTs = now;

      if (!state.isPaused) {
        state.timeRemaining -= dt;
        if (state.timeRemaining <= 0) {
          endSession();
          return;
        }
        updateHUD();
      }
      
      state.rafId = requestAnimationFrame(loop);
    }

    // ============================
    // SESSION MANAGEMENT
    // ============================
    function startSession() {
      const durMin = utils.validateDuration(durIn.value);
      if (!durMin) {
        durError.classList.add('show');
        durIn.focus();
        return;
      }
      durError.classList.remove('show');

      state.sessionDurationMs = durMin * 60 * 1000;
      state.timeRemaining = state.sessionDurationMs;
      state.scale = SIZE_MAP[sizeSelect.value] || 1;

      const diff = DIFFICULTY_MAP[difficultySelect.value] || DIFFICULTY_MAP.medium;
      // IMPROVEMENT 3: Store base values for per-char adjustment
      state.baseBorderWidth = diff.borderWidth;
      state.baseTolerance = diff.tolerance;
      state.baseMinAccuracy = diff.minAccuracy;
      state.borderWidth = state.baseBorderWidth;
      state.tolerance = state.baseTolerance;
      state.minAccuracy = state.baseMinAccuracy;

      state.score = state.completed = state.perfectCount = 0;
      state.charQueue = [];
      state.accuracySum = 0;
      state.accuracyCount = 0;
      state.undoHistory = [];

      state.isActive = true;
      state.isPaused = false;
      state.prevTs = 0;
      document.body.classList.add('playing');

      setupCanvas();
      nextChar();

      requestAnimationFrame(ts => {
        state.prevTs = ts;
        state.rafId = requestAnimationFrame(loop);
      });

      audio.playClick();
    }

    function pauseSession() {
      if (!state.isActive) return;
      state.isPaused = !state.isPaused;
      
      if (state.isPaused) {
        state.prevTs = 0;
        pauseBtn.textContent = 'Resume';
        audio.playClick();
      } else {
        pauseBtn.textContent = 'Pause';
        audio.playClick();
      }
    }

    function exitToSettings() {
      if (state.isActive) {
        state.isActive = false;
        cancelAnimationFrame(state.rafId);
      }
      clearTimeout(state.completionTimer);
      state.prevTs = 0;
      document.body.classList.remove('playing');
      pauseBtn.textContent = 'Pause';
      doneModal.classList.remove('open');
      audio.playClick();
    }

    function endSession() {
      state.isActive = false;
      cancelAnimationFrame(state.rafId);
      clearTimeout(state.completionTimer);
      state.prevTs = 0;
      document.body.classList.remove('playing');

      const avgAcc = state.accuracyCount > 0 ? Math.round(state.accuracySum / state.accuracyCount) : 0;
      $('#fScore').textContent = String(state.score);
      $('#fCompleted').textContent = String(state.completed);
      $('#fAccuracy').textContent = avgAcc + '%';
      $('#fPerfect').textContent = String(state.perfectCount);

      const prev = storage.get(CONSTANTS.STORAGE_KEY_PREFIX + CONSTANTS.EXERCISE_ID, 0) || 0;
      if (state.score > prev) {
        const saved = storage.set(CONSTANTS.STORAGE_KEY_PREFIX + CONSTANTS.EXERCISE_ID, state.score);
        if (!saved) console.warn('Failed to save high score');
      }
      
      doneModal.classList.add('open');
      setTimeout(() => $('#newSession').focus(), 100);
      audio.playSuccess();
    }

    // ============================
    // STARS BACKGROUND
    // ============================
    function generateStars(container, count = CONSTANTS.STAR_COUNT) {
      if (!container) return;
      container.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const star = document.createElement('div');
        star.style.position = 'absolute';
        const size = Math.random() * 3 + 1;
        star.style.width = size + 'px';
        star.style.height = size + 'px';
        star.style.backgroundColor = i % 20 === 0 ? '#6fd3f5' : 'white';
        star.style.borderRadius = '50%';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.opacity = Math.random() * 0.7 + 0.3;
        star.style.animation = `twinkle ${Math.random() * 4 + 2}s ease-in-out infinite`;
        star.style.animationDelay = `${Math.random() * 3}s`;
        star.style.boxShadow = size > 2 ? '0 0 4px rgba(111,211,245,0.5)' : 'none';
        container.appendChild(star);
      }
    }

    // ============================
    // EVENT LISTENERS
    // ============================
    canvas.addEventListener('pointerdown', startDrawing);
    canvas.addEventListener('pointermove', draw);
    canvas.addEventListener('pointerup', endDrawing);
    canvas.addEventListener('pointerleave', endDrawing);
    canvas.addEventListener('pointercancel', endDrawing);

    startBtn.addEventListener('click', () => {
      doneModal.classList.remove('open');
      tutorialModal.classList.remove('open');
      startSession();
    });
    pauseBtn.addEventListener('click', pauseSession);
    undoBtn.addEventListener('click', undoLastStroke);
    clearBtn.addEventListener('click', clearDrawing);
    skipBtn.addEventListener('click', skipChar);
    exitBtn.addEventListener('click', exitToSettings);
    tutorialBtn.addEventListener('click', () => {
      tutorialModal.classList.add('open');
      setTimeout(() => $('#closeTutorial').focus(), 100);
    });
    $('#closeTutorial').addEventListener('click', () => tutorialModal.classList.remove('open'));
    $('#newSession').addEventListener('click', () => {
      doneModal.classList.remove('open');
      startSession();
    });

    doneModal.addEventListener('click', e => {
      if (e.target === doneModal) doneModal.classList.remove('open');
    });
    tutorialModal.addEventListener('click', e => {
      if (e.target === tutorialModal) tutorialModal.classList.remove('open');
    });

    addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        if (doneModal.classList.contains('open')) doneModal.classList.remove('open');
        else if (tutorialModal.classList.contains('open')) tutorialModal.classList.remove('open');
        else if (state.isActive) exitToSettings();
      }
      
      if (!state.isActive) return;
      
      if (e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault();
        pauseSession();
      } else if ((e.key === 'c' || e.key === 'C') && !state.isPaused) {
        clearDrawing();
      } else if ((e.key === 'n' || e.key === 'N') && !state.isPaused) {
        skipChar();
      } else if ((e.key === 'z' || e.key === 'Z') && e.ctrlKey && !state.isPaused) {
        e.preventDefault();
        undoLastStroke();
      }
    });

    addEventListener('resize', () => {
      if (state.isActive && !state.isPaused) {
        setupCanvas();
        drawStrokePath();
        
        if (state.drawnPoints.length > 0) {
          ctx.save();
          ctx.strokeStyle = 'rgba(111,211,245,0.9)';
          ctx.lineWidth = 10;
          drawCatmullRom(state.drawnPoints);
          ctx.restore();
        }
      }
    });

    document.body.addEventListener('touchmove', e => {
      if (state.isActive) e.preventDefault();
    }, { passive: false });

    // ============================
    // INITIALIZATION
    // ============================
    if (starsContainer) generateStars(starsContainer);
    updateHUD();

    const hasSeenTutorial = storage.get('hasSeenTutorial', false);
    if (!hasSeenTutorial) {
      setTimeout(() => {
        tutorialModal.classList.add('open');
        setTimeout(() => $('#closeTutorial').focus(), 100);
        storage.set('hasSeenTutorial', true);
      }, 500);
    }
  </script>
</body>
</html>