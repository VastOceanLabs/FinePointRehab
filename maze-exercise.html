<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-RVKCCWBFKE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-RVKCCWBFKE');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Cosmic Maze Exercise - Fine Motor Skills Rehabilitation | Fine Point Rehab</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Interactive cosmic maze exercise for fine motor skills rehabilitation, stroke recovery, and upper limb therapy. Digital therapeutic exercise for neurological rehabilitation, hand-eye coordination, and dexterity improvement. Suitable for occupational therapy, physiotherapy, and home-based rehabilitation programs. Helps patients with stroke, brain injury, cerebral palsy, and neurological conditions improve motor control, precision movements, and functional recovery.">
    
    <meta name="keywords" content="fine motor skills exercises, upper limb rehabilitation, stroke recovery exercises, neuro rehabilitation games, occupational therapy activities, physiotherapy exercises, hand therapy exercises, motor control training, digital therapeutics, home rehabilitation exercises, hand-eye coordination, dexterity training, brain injury rehabilitation, neurological therapy, therapeutic games, motor function recovery, arm rehabilitation, finger exercises, precision movement therapy, adaptive therapy">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Cosmic Maze Exercise - Fine Motor Skills & Upper Limb Rehabilitation | Fine Point Rehab">
    <meta property="og:description" content="Interactive digital therapeutic exercise for fine motor skills rehabilitation, stroke recovery, and neurological therapy. Improve hand-eye coordination and motor control through engaging maze navigation.">
    <meta property="og:type" content="website">
    <meta property="og:image" content="/api/placeholder/1200/630">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Cosmic Maze Exercise - Fine Motor Skills Rehabilitation | Fine Point Rehab">
    <meta name="twitter:description" content="Digital therapeutic maze game for upper limb rehabilitation, fine motor skills training, and neurological recovery.">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://finepointrehab.com/cosmic-maze-exercise">
    
    <!-- Schema.org Markup -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "MedicalWebPage",
        "name": "Cosmic Maze Exercise - Fine Motor Skills Rehabilitation | Fine Point Rehab",
        "description": "Interactive digital therapeutic exercise for fine motor skills rehabilitation, stroke recovery, and upper limb therapy",
        "medicalAudience": {
            "@type": "MedicalAudience",
            "audienceType": "Patient",
            "healthCondition": [
                "Stroke",
                "Brain Injury",
                "Cerebral Palsy",
                "Motor Impairment",
                "Upper Limb Dysfunction"
            ]
        },
        "specialty": [
            "Occupational Therapy",
            "Physical Therapy",
            "Neurorehabilitation"
        ],
        "benefits": [
            "Improves fine motor control",
            "Enhances hand-eye coordination",
            "Develops precision movements",
            "Supports neuroplasticity",
            "Facilitates motor recovery"
        ]
    }
    </script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            background: #121d33;
            color: white;
            min-height: 100vh;
            /* Handle safe areas for devices with notches/nav bars */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* Account for safe areas */
            padding-bottom: env(safe-area-inset-bottom, 0);
        }
        
        #maze-container {
            position: relative;
            background-color: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(111, 211, 245, 0.3);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(111, 211, 245, 0.2);
            touch-action: none;
            outline: none;
        }
        
        .maze-wall {
            position: absolute;
            background: linear-gradient(135deg, rgba(7, 25, 59, 0.9), rgba(11, 42, 88, 0.9));
            border: 1px solid rgba(111, 211, 245, 0.3);
            box-shadow: 0 0 8px rgba(111, 211, 245, 0.2);
        }
        
        /* Path lines styling - dotted lines in center of paths */
        .path-line {
            position: absolute;
            z-index: 2;
        }
        
        .path-line.horizontal {
            height: 2px;
            background-image: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 4px,
                rgba(111, 211, 245, 0.5) 4px,
                rgba(111, 211, 245, 0.5) 8px
            );
        }
        
        .path-line.vertical {
            width: 2px;
            background-image: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 4px,
                rgba(111, 211, 245, 0.5) 4px,
                rgba(111, 211, 245, 0.5) 8px
            );
        }
        
        /* Path intersection nodes */
        .path-node {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(111, 211, 245, 0.7);
            border-radius: 50%;
            z-index: 3;
            transform: translate(-50%, -50%);
        }
        
        /* IMPROVED PLAYER SPACESHIP */
        #player {
            position: absolute;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 40'%3E%3Cdefs%3E%3ClinearGradient id='bodyGrad' x1='0%25' y1='0%25' x2='0%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23e8eef5'/%3E%3Cstop offset='100%25' style='stop-color:%239fb5d4'/%3E%3C/linearGradient%3E%3ClinearGradient id='windowGrad' x1='0%25' y1='0%25' x2='0%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%236495ed'/%3E%3Cstop offset='100%25' style='stop-color:%232856a8'/%3E%3C/linearGradient%3E%3ClinearGradient id='flameGrad' x1='0%25' y1='0%25' x2='0%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23ffef00'/%3E%3Cstop offset='50%25' style='stop-color:%23ff8c00'/%3E%3Cstop offset='100%25' style='stop-color:%23ff4500'/%3E%3C/linearGradient%3E%3C/defs%3E%3C!-- Main body --%3E%3Cellipse cx='20' cy='20' rx='12' ry='16' fill='url(%23bodyGrad)' stroke='%23364a69' stroke-width='1'/%3E%3C!-- Cockpit window --%3E%3Cellipse cx='20' cy='12' rx='6' ry='7' fill='url(%23windowGrad)' stroke='%231a3a6e' stroke-width='0.5'/%3E%3C!-- Window shine --%3E%3Cellipse cx='18' cy='10' rx='2' ry='3' fill='%23a8ccff' opacity='0.6'/%3E%3C!-- Side fins --%3E%3Cpath d='M8 18 L2 28 L8 26 Z' fill='%23536b8a' stroke='%23364a69' stroke-width='0.5'/%3E%3Cpath d='M32 18 L38 28 L32 26 Z' fill='%23536b8a' stroke='%23364a69' stroke-width='0.5'/%3E%3C!-- Engine nozzles --%3E%3Crect x='14' y='32' width='4' height='3' rx='1' fill='%23434d5a'/%3E%3Crect x='22' y='32' width='4' height='3' rx='1' fill='%23434d5a'/%3E%3C!-- Engine flames --%3E%3Cellipse cx='16' cy='36' rx='3' ry='5' fill='url(%23flameGrad)' opacity='0.9'/%3E%3Cellipse cx='24' cy='36' rx='3' ry='5' fill='url(%23flameGrad)' opacity='0.9'/%3E%3C!-- Body details --%3E%3Cline x1='12' y1='20' x2='28' y2='20' stroke='%23536b8a' stroke-width='0.5'/%3E%3Cline x1='12' y1='24' x2='28' y2='24' stroke='%23536b8a' stroke-width='0.5'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transform: translate(-50%, -50%) rotate(90deg);
            box-shadow: 0 0 20px rgba(111, 211, 245, 0.8);
            z-index: 10;
            cursor: pointer;
            touch-action: none;
            transition: box-shadow 0.3s ease;
            animation: hover 2s ease-in-out infinite;
        }
        
        @keyframes hover {
            0%, 100% { transform: translate(-50%, -50%) rotate(90deg) translateY(0); }
            50% { transform: translate(-50%, -50%) rotate(90deg) translateY(-2px); }
        }
        
        /* IMPROVED EARTH GOAL */
        #goal {
            position: absolute;
            width: 44px;
            height: 44px;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 50 50'%3E%3Cdefs%3E%3CradialGradient id='earthGlow'%3E%3Cstop offset='70%25' style='stop-color:%2300ff00;stop-opacity:0'/%3E%3Cstop offset='100%25' style='stop-color:%2300ff00;stop-opacity:0.3'/%3E%3C/radialGradient%3E%3C/defs%3E%3C!-- Outer glow --%3E%3Ccircle cx='25' cy='25' r='24' fill='url(%23earthGlow)'/%3E%3C!-- Earth sphere --%3E%3Ccircle cx='25' cy='25' r='20' fill='%232E86AB' stroke='%231a5a7a' stroke-width='0.5'/%3E%3C!-- Continents --%3E%3Cpath d='M15 15 Q20 12 25 14 T35 18 Q33 25 30 28 Q25 30 20 28 Q15 25 15 20 Z' fill='%23228B22' opacity='0.8'/%3E%3Cpath d='M10 25 Q12 23 15 24 Q18 28 15 32 Q12 33 10 30 Z' fill='%23228B22' opacity='0.8'/%3E%3Cpath d='M30 10 Q35 12 37 15 Q35 18 32 16 Q30 13 30 10 Z' fill='%23228B22' opacity='0.8'/%3E%3Cpath d='M25 32 Q28 35 32 36 Q35 38 33 40 Q28 39 25 36 Z' fill='%23228B22' opacity='0.8'/%3E%3C!-- Cloud wisps --%3E%3Cpath d='M12 18 Q15 17 18 18' stroke='white' stroke-width='1' fill='none' opacity='0.4'/%3E%3Cpath d='M28 22 Q31 21 34 22' stroke='white' stroke-width='1' fill='none' opacity='0.4'/%3E%3Cpath d='M20 35 Q23 34 26 35' stroke='white' stroke-width='1' fill='none' opacity='0.4'/%3E%3C!-- Atmosphere highlight --%3E%3Cpath d='M10 20 Q10 10 20 7 Q30 5 38 12' stroke='%2387CEEB' stroke-width='1.5' fill='none' opacity='0.5'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 50%;
            z-index: 5;
            box-shadow: 0 0 30px rgba(46, 134, 171, 0.7);
            animation: earth-rotate 20s linear infinite;
            transform: translate(-50%, -50%);
        }
        
        @keyframes earth-rotate {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        /* START and END labels */
        .point-label {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 10px;
            transform: translate(-50%, -50%);
            z-index: 20;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
            white-space: nowrap;
        }
        
        #start-label {
            color: rgba(111, 211, 245, 1);
            background-color: rgba(8, 15, 35, 0.7);
            border: 1px solid rgba(111, 211, 245, 0.7);
            box-shadow: 0 0 8px rgba(111, 211, 245, 0.5);
        }
        
        #end-label {
            color: rgb(76, 175, 80);
            background-color: rgba(8, 15, 35, 0.7);
            border: 1px solid rgba(76, 175, 80, 0.7);
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }
        
        .path-trace {
            position: absolute;
            background-color: rgba(111, 211, 245, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2;
        }
        
        #timer-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 8px;
            background-color: rgba(111, 211, 245, 0.9);
            width: 100%;
            z-index: 20;
            transition: width 0.1s linear;
        }
        
        #settings-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(8, 15, 35, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.1);
            z-index: 100;
            width: 80%;
            max-width: 400px;
            max-height: 85vh; /* Limit height on mobile */
            overflow-y: auto; /* Allow scrolling if content is too tall */
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Add extra bottom padding for mobile nav bars */
            padding-bottom: calc(25px + env(safe-area-inset-bottom, 20px));
            /* Smooth scrolling on mobile */
            -webkit-overflow-scrolling: touch;
        }
        
        /* Add subtle scroll indicator for mobile */
        #settings-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        #settings-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        #settings-panel::-webkit-scrollbar-thumb {
            background: rgba(111, 211, 245, 0.5);
            border-radius: 3px;
        }
        
        #settings-panel h2 {
            text-align: center;
            color: white;
            margin-top: 0;
            margin-bottom: 25px;
            font-size: 24px;
            letter-spacing: 0.5px;
        }
        
        #settings-toggle {
            position: fixed;
            bottom: 15px;
            right: 15px;
            background-color: rgba(111, 211, 245, 0.8);
            color: #121d33;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 90;
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #settings-toggle:hover {
            background-color: rgba(111, 211, 245, 1);
            transform: translateY(-2px);
        }
        
        #home-button {
            position: fixed;
            bottom: calc(15px + env(safe-area-inset-bottom, 0px));
            right: calc(15px + env(safe-area-inset-right, 0px));
            background-color: rgba(111, 211, 245, 0.8);
            color: #121d33;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 90;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        
        #home-button:hover {
            background-color: rgba(111, 211, 245, 1);
            transform: translateY(-2px);
        }
        
        .game-description {
            background-color: rgba(0, 10, 30, 0.6);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(111, 211, 245, 0.3);
        }
        
        .game-description h3 {
            color: rgba(111, 211, 245, 1);
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        
        .game-description p {
            margin: 0 0 12px 0;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            line-height: 1.4;
        }
        
        .game-description p:last-child {
            margin-bottom: 0;
        }
        
        .setting-help {
            display: block;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            margin-top: 5px;
            font-style: italic;
        }
        
        .settings-group {
            margin-bottom: 20px;
        }
        
        .settings-label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: white;
            font-size: 16px;
        }
        
        select, input {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 16px; /* 16px prevents zoom on iOS */
            background-color: rgba(0, 10, 30, 0.8);
            color: white;
            /* Prevent zoom on focus for mobile */
            touch-action: manipulation;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: rgba(111, 211, 245, 0.8);
            box-shadow: 0 0 0 2px rgba(111, 211, 245, 0.3);
        }
        
        button {
            background-color: rgba(111, 211, 245, 0.9);
            color: #121d33;
            border: none;
            border-radius: 10px;
            padding: 12px 15px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            /* Ensure minimum touch target size */
            min-height: 48px;
        }
        
        button:hover {
            background-color: rgba(111, 211, 245, 1);
            transform: translateY(-2px);
        }
        
        #stats-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(8, 15, 35, 0.8);
            padding: 15px;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
        }
        
        .stat-box {
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: rgba(111, 211, 245, 1);
        }
        
        .stat-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        #completion-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(8, 15, 35, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.1);
            text-align: center;
            max-width: 80%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Add padding for mobile nav bars */
            padding-bottom: calc(30px + env(safe-area-inset-bottom, 0px));
        }
        
        #completion-message h2 {
            color: white;
            margin-top: 0;
        }
        
        #completion-scores {
            margin: 20px 0;
            font-size: 18px;
        }
        
        .score-highlight {
            color: rgba(111, 211, 245, 1);
            font-weight: bold;
        }
        
        #stars-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            overflow: hidden;
            pointer-events: none;
        }
        
        .star {
            position: absolute;
            background-color: white;
            width: 2px;
            height: 2px;
            border-radius: 50%;
            opacity: 0.4;
        }
        
        .instructions {
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
            font-size: 16px;
            padding: 15px;
            background-color: rgba(8, 15, 35, 0.7);
            border-radius: 8px;
            margin-bottom: 15px;
            max-width: 600px;
        }
        
        #error-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 200;
            display: none;
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from { transform: translate(-50%, -100%); }
            to { transform: translate(-50%, 0); }
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Mobile-specific styles */
        .mobile-device #settings-panel {
            /* Ensure panel doesn't go too high on mobile */
            top: 45%;
        }
        
        .mobile-device .instructions {
            /* Slightly smaller on mobile to save space */
            margin-bottom: 10px;
        }
        
        @media (max-width: 768px) {
            .stat-value {
                font-size: 20px;
            }
            
            .stat-label {
                font-size: 12px;
            }
            
            .instructions {
                font-size: 14px;
                padding: 10px;
            }
            
            .point-label {
                font-size: 10px;
                padding: 3px 6px;
            }
            
            #settings-panel {
                width: 90%;
                padding: 20px;
                padding-bottom: calc(30px + env(safe-area-inset-bottom, 20px));
                max-height: 80vh;
            }
            
            #settings-panel h2 {
                font-size: 20px;
                margin-bottom: 20px;
            }
            
            .game-description {
                padding: 12px;
            }
            
            .game-description h3 {
                font-size: 14px;
            }
            
            .game-description p {
                font-size: 13px;
            }
            
            .settings-label {
                font-size: 14px;
            }
            
            select, input {
                padding: 10px;
                font-size: 14px;
            }
            
            button {
                padding: 14px 15px;
                font-size: 14px;
                /* Ensure button is well above system nav */
                margin-bottom: 10px;
            }
            
            .setting-help {
                font-size: 11px;
            }
            
            /* Smaller home button on mobile */
            #home-button {
                width: 50px;
                height: 50px;
                font-size: 12px;
            }
            
            /* Adjust stats panel for mobile */
            #stats-panel {
                padding: 12px 10px;
                padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
            }
            
            /* Ensure maze container doesn't go under nav bars */
            #maze-container {
                margin-bottom: 10px;
            }
        }
        
        /* Extra small devices */
        @media (max-width: 400px) {
            #settings-panel {
                width: 95%;
                padding: 15px;
                padding-bottom: calc(25px + env(safe-area-inset-bottom, 20px));
            }
            
            .game-description {
                display: none; /* Hide description on very small screens to save space */
            }
            
            .instructions {
                font-size: 13px;
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="stars-container"></div>
        <div id="timer-bar" class="hidden"></div>
        <div id="error-message"></div>
        <p class="instructions">Guide the spaceship through the cosmic maze to reach Earth. This therapeutic exercise improves fine motor skills, hand-eye coordination, and precision movements. Drag the spaceship or use arrow keys to navigate along the dotted lines. Perfect for stroke rehabilitation, neurological recovery, and upper limb therapy.</p>
        
        <div id="maze-container" tabindex="0"></div>
        
        <button id="home-button"
                aria-label="Go to Home"
                onclick="window.location.href='index.html'"
                title="Return to Home">
            Home
        </button>
        
        <div id="settings-panel">
            <h2>Cosmic Maze Exercise</h2>
            
            <div class="game-description">
                <h3>About This Exercise</h3>
                <p>Navigate a spaceship through randomly generated mazes to reach Earth. This therapeutic exercise helps improve fine motor skills, hand-eye coordination, and precision movements.</p>
                
                <h3>How to Play</h3>
                <p><strong>Controls:</strong> Drag the spaceship or use arrow keys to move along the dotted path lines. The spaceship can only move to connected areas - no cutting through walls!</p>
                
                <p><strong>Goal:</strong> Guide your spaceship from the START point to the FINISH (Earth) as quickly as possible. Complete as many mazes as you can within your session time.</p>
            </div>
            
            <div class="settings-group">
                <label class="settings-label">Difficulty Level:</label>
                <select id="difficulty" aria-label="Select difficulty level">
                    <option value="easy" selected>Easy - Wide paths, larger spaceship (beginners)</option>
                    <option value="medium">Medium - Standard paths and spaceship size</option>
                    <option value="hard">Hard - Narrow paths, smaller spaceship (advanced)</option>
                </select>
                <small class="setting-help">Higher difficulty requires more precise movements and motor control.</small>
            </div>
            
            <div class="settings-group">
                <label class="settings-label">Session Duration:</label>
                <input type="number" id="session-duration" min="1" max="10" value="5" aria-label="Set session duration">
                <small class="setting-help">How many minutes to practice (1-10 minutes recommended).</small>
            </div>
            
            <div class="settings-group">
                <label class="settings-label">Movement Trail:</label>
                <select id="show-trace" aria-label="Enable or disable path trace">
                    <option value="yes" selected>Show Trail - See where you've moved</option>
                    <option value="no">No Trail - Clean view</option>
                </select>
                <small class="setting-help">The trail helps track your movement patterns for progress monitoring.</small>
            </div>
            
            <button id="start-session">Start Exercise</button>
        </div>
        
        <div id="stats-panel" class="hidden">
            <div class="stat-box">
                <div id="mazes-completed" class="stat-value">0</div>
                <div class="stat-label">Completed</div>
            </div>
            <div class="stat-box">
                <div id="current-maze" class="stat-value">1</div>
                <div class="stat-label">Current Maze</div>
            </div>
            <div class="stat-box">
                <div id="time-left" class="stat-value">5:00</div>
                <div class="stat-label">Time Left</div>
            </div>
            <div class="stat-box">
                <div id="avg-time" class="stat-value">0.0s</div>
                <div class="stat-label">Avg. Completion</div>
            </div>
        </div>
        
        <div id="completion-message" class="hidden">
            <h2>Therapy Session Complete!</h2>
            <div id="completion-scores">
                <p>Mazes Completed: <span id="final-completed" class="score-highlight">0</span></p>
                <p>Average Completion Time: <span id="final-avg-time" class="score-highlight">0.0s</span></p>
                <p>Motor Performance Score: <span id="final-score" class="score-highlight">0</span></p>
            </div>
            <button id="restart-button">Start New Therapy Session</button>
        </div>
    </div>
    
    <script>
        // Game elements
        const gameContainer = document.getElementById('game-container');
        const mazeContainer = document.getElementById('maze-container');
        const timerBar = document.getElementById('timer-bar');
        const settingsPanel = document.getElementById('settings-panel');
        const statsPanel = document.getElementById('stats-panel');
        const completionMessage = document.getElementById('completion-message');
        const starsContainer = document.getElementById('stars-container');
        const instructions = document.querySelector('.instructions');
        const errorMessage = document.getElementById('error-message');
        
        // Create stars for background effect
        const starsCount = 150;
        
        for (let i = 0; i < starsCount; i++) {
            const star = document.createElement('div');
            star.classList.add('star');
            
            // Random position
            star.style.left = `${Math.random() * 100}%`;
            star.style.top = `${Math.random() * 100}%`;
            
            // Random size
            const size = Math.random() * 2 + 0.5;
            star.style.width = `${size}px`;
            star.style.height = `${size}px`;
            
            // Random opacity for subtle effect
            star.style.opacity = Math.random() * 0.4 + 0.1;
            
            starsContainer.appendChild(star);
        }
        
        // Settings elements
        const difficultySelect = document.getElementById('difficulty');
        const sessionDurationInput = document.getElementById('session-duration');
        const showTraceSelect = document.getElementById('show-trace');
        const startSessionButton = document.getElementById('start-session');
        const restartButton = document.getElementById('restart-button');
        
        // Stats elements
        const mazesCompletedElement = document.getElementById('mazes-completed');
        const currentMazeElement = document.getElementById('current-maze');
        const timeLeftElement = document.getElementById('time-left');
        const avgTimeElement = document.getElementById('avg-time');
        
        // Completion elements
        const finalCompletedElement = document.getElementById('final-completed');
        const finalAvgTimeElement = document.getElementById('final-avg-time');
        const finalScoreElement = document.getElementById('final-score');
        
        // Game variables
        let isSessionActive = false;
        let sessionDuration = 5 * 60 * 1000; // 5 minutes in milliseconds
        let timeRemaining = 0;
        let timerInterval = null;
        let mazesCompleted = 0;
        let currentMaze = 1;
        let totalCompletionTime = 0;
        let mazeStartTime = 0;
        let showTrace = true;
        let player = null;
        let goal = null;
        let startLabel = null;
        let endLabel = null;
        let isDragging = false;
        let maze = [];
        let mazeWidth = 600;
        let mazeHeight = 400;
        let cellSize = 50;
        let wallThickness = 10;
        let currentDifficulty = 'easy';
        let pathTraces = [];
        let pathNodes = []; // Store path node positions for navigation
        let playerNodeIndex = 0; // Current player position on path
        
        // Event handlers storage - ADD THIS TO TRACK EVENT LISTENERS
        let eventHandlers = {
            keydown: null,
            mousedown: null,
            touchstart: null,
            mousemove: null,
            touchmove: null,
            mouseup: null,
            touchend: null
        };
        
        // Difficulty settings
        const difficultySizes = {
            'easy': { cellSize: 60, wallThickness: 12 },
            'medium': { cellSize: 45, wallThickness: 10 },
            'hard': { cellSize: 30, wallThickness: 8 }
        };
        
        // Initialize the game once the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Add mobile class if on mobile device
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                document.body.classList.add('mobile-device');
            }
            
            adjustMazeSize();
            showSettings();
        });
        
        // Start new session
        startSessionButton.addEventListener('click', startSession);
        restartButton.addEventListener('click', () => {
            completionMessage.classList.add('hidden');
            settingsPanel.classList.remove('hidden');
        });
        
        // Adjust maze size based on screen
        function adjustMazeSize() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Account for mobile UI elements
            const safeBottomSpace = 100; // Space for stats panel and system UI
            const safeTopSpace = 80; // Space for instructions
            
            // Maximum maze size based on screen (with margins)
            mazeWidth = Math.min(600, windowWidth * 0.9);
            
            // On mobile, be more conservative with height
            if (windowWidth <= 768) {
                mazeHeight = Math.min(400, (windowHeight - safeBottomSpace - safeTopSpace) * 0.8);
            } else {
                mazeHeight = Math.min(400, windowHeight * 0.6);
            }
            
            // Update maze container size
            mazeContainer.style.width = `${mazeWidth}px`;
            mazeContainer.style.height = `${mazeHeight}px`;
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            adjustMazeSize();
            if (isSessionActive) {
                // Regenerate maze with new size
                generateMaze();
            }
        });
        
        // Clear intervals on page unload
        window.addEventListener('beforeunload', () => {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            // Clean up any remaining event listeners
            removeAllEventListeners();
        });
        
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            setTimeout(() => {
                errorMessage.style.display = 'none';
            }, 3000);
        }
        
        // Update stats display
        function updateStats() {
            mazesCompletedElement.textContent = mazesCompleted;
            currentMazeElement.textContent = currentMaze;
            
            // Calculate and display average completion time
            const avgTime = mazesCompleted > 0 ? (totalCompletionTime / mazesCompleted / 1000).toFixed(1) : '0.0';
            avgTimeElement.textContent = `${avgTime}s`;
        }
        
        // Update timer display
        function updateTimer() {
            const minutes = Math.floor(timeRemaining / 60000);
            const seconds = Math.floor((timeRemaining % 60000) / 1000);
            timeLeftElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Clear maze elements AND event listeners
        function clearMaze() {
            console.log("Clearing maze");
            
            // First, remove all event listeners
            removeAllEventListeners();
            
            // Remove all child elements from maze container
            while (mazeContainer.firstChild) {
                mazeContainer.removeChild(mazeContainer.firstChild);
            }
            
            // Clear path traces array
            pathTraces = [];
            
            // Ensure pathNodes is reset to an empty array
            pathNodes = [];
            
            console.log("Maze cleared");
        }
        
        // Remove all event listeners
        function removeAllEventListeners() {
            // Remove keyboard event listener
            if (eventHandlers.keydown) {
                mazeContainer.removeEventListener('keydown', eventHandlers.keydown);
                eventHandlers.keydown = null;
            }
            
            // Remove mouse/touch event listeners
            if (player) {
                if (eventHandlers.mousedown) {
                    player.removeEventListener('mousedown', eventHandlers.mousedown);
                    eventHandlers.mousedown = null;
                }
                
                if (eventHandlers.touchstart) {
                    player.removeEventListener('touchstart', eventHandlers.touchstart);
                    eventHandlers.touchstart = null;
                }
            }
            
            // Remove document level event listeners
            if (eventHandlers.mousemove) {
                document.removeEventListener('mousemove', eventHandlers.mousemove);
                eventHandlers.mousemove = null;
            }
            
            if (eventHandlers.touchmove) {
                document.removeEventListener('touchmove', eventHandlers.touchmove);
                eventHandlers.touchmove = null;
            }
            
            if (eventHandlers.mouseup) {
                document.removeEventListener('mouseup', eventHandlers.mouseup);
                eventHandlers.mouseup = null;
            }
            
            if (eventHandlers.touchend) {
                document.removeEventListener('touchend', eventHandlers.touchend);
                eventHandlers.touchend = null;
            }
        }
        
        // Show settings panel
        function showSettings() {
            settingsPanel.classList.remove('hidden');
            statsPanel.classList.add('hidden');
            timerBar.classList.add('hidden');
        }
        
        function startSession() {
            try {
                // Get settings
                currentDifficulty = difficultySelect.value;
                sessionDuration = parseInt(sessionDurationInput.value) * 60 * 1000; // Convert minutes to ms
                showTrace = showTraceSelect.value === 'yes';
                
                // Initialize game state
                mazesCompleted = 0;
                currentMaze = 1;
                totalCompletionTime = 0;
                timeRemaining = sessionDuration;
                
                console.log("Session initialized, settings applied");
                
                // Update UI
                updateStats();
                updateTimer();
                
                // Clear any existing maze and event listeners
                clearMaze();
                
                // Hide settings, show stats
                settingsPanel.classList.add('hidden');
                instructions.classList.remove('hidden');
                statsPanel.classList.remove('hidden');
                timerBar.classList.remove('hidden');
                
                console.log("UI updated, about to start timer");
                
                // Start timer
                isSessionActive = true;
                
                timerInterval = setInterval(() => {
                    timeRemaining -= 100; // Update every 100ms
                    
                    // Update timer bar
                    const progress = timeRemaining / sessionDuration;
                    timerBar.style.width = `${progress * 100}%`;
                    
                    // Update time display
                    updateTimer();
                    
                    // Check if session is over
                    if (timeRemaining <= 0) {
                        endSession();
                    }
                }, 100);
                
                console.log("Timer started, about to generate maze");
                
                // Generate first maze
                generateMaze();
                mazeStartTime = Date.now();
                
                // Focus on maze for keyboard controls
                mazeContainer.focus();
                
                console.log("Session successfully started");
                
            } catch (error) {
                console.error('Failed to start session:', error);
                showError('Failed to start session: ' + error.message);
            }
        }
        
        // Complete current maze and generate a new one
        function completeCurrentMaze() {
            // Calculate completion time
            const completionTime = Date.now() - mazeStartTime;
            totalCompletionTime += completionTime;
            
            // Update statistics
            mazesCompleted++;
            currentMaze++;
            updateStats();
            
            // Generate a new maze
            generateMaze();
            mazeStartTime = Date.now();
        }
        
        // End the current session and show results
        function endSession() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Clean up
            isSessionActive = false;
            clearMaze();
            
            // Hide timer and stats panels
            timerBar.classList.add('hidden');
            statsPanel.classList.add('hidden');
            
            // Calculate final score
            const avgTime = mazesCompleted > 0 ? (totalCompletionTime / mazesCompleted / 1000).toFixed(1) : '0.0';
            const performanceScore = Math.round((mazesCompleted * 100) / (avgTime > 0 ? avgTime : 1));
            
            // Show completion message with results
            finalCompletedElement.textContent = mazesCompleted;
            finalAvgTimeElement.textContent = `${avgTime}s`;
            finalScoreElement.textContent = performanceScore;
            completionMessage.classList.remove('hidden');
        }
        
        // Get unvisited neighboring cells for maze generation
        function getUnvisitedNeighbors(x, y) {
            const neighbors = [];
            const rows = maze.length;
            const cols = maze[0].length;
            
            // Check each direction (up, right, down, left)
            const directions = [
                { dx: 0, dy: -1 }, // up
                { dx: 1, dy: 0 },  // right
                { dx: 0, dy: 1 },  // down
                { dx: -1, dy: 0 }  // left
            ];
            
            // Shuffle directions to create a more random maze
            shuffleArray(directions);
            
            for (const dir of directions) {
                const newX = x + dir.dx;
                const newY = y + dir.dy;
                
                // Check if the new coordinates are within the grid
                if (newX >= 0 && newX < cols && newY >= 0 && newY < rows) {
                    // Check if the neighbor has not been visited
                    if (!maze[newY][newX].visited) {
                        neighbors.push({ x: newX, y: newY });
                    }
                }
            }
            
            return neighbors;
        }
        
        // Helper function to shuffle an array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        // Create maze walls based on the generated maze data
        function createMazeWalls(cols, rows) {
            // Create outer walls
            const topWall = document.createElement('div');
            topWall.className = 'maze-wall';
            topWall.style.top = '0';
            topWall.style.left = '0';
            topWall.style.width = `${cols * cellSize}px`;
            topWall.style.height = `${wallThickness}px`;
            mazeContainer.appendChild(topWall);
            
            const leftWall = document.createElement('div');
            leftWall.className = 'maze-wall';
            leftWall.style.top = '0';
            leftWall.style.left = '0';
            leftWall.style.width = `${wallThickness}px`;
            leftWall.style.height = `${rows * cellSize}px`;
            mazeContainer.appendChild(leftWall);
            
            const rightWall = document.createElement('div');
            rightWall.className = 'maze-wall';
            rightWall.style.top = '0';
            rightWall.style.left = `${cols * cellSize - wallThickness}px`;
            rightWall.style.width = `${wallThickness}px`;
            rightWall.style.height = `${rows * cellSize}px`;
            mazeContainer.appendChild(rightWall);
            
            const bottomWall = document.createElement('div');
            bottomWall.className = 'maze-wall';
            bottomWall.style.top = `${rows * cellSize - wallThickness}px`;
            bottomWall.style.left = '0';
            bottomWall.style.width = `${cols * cellSize}px`;
            bottomWall.style.height = `${wallThickness}px`;
            mazeContainer.appendChild(bottomWall);
            
            // Create inner walls based on the maze data
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = maze[i][j];
                    
                    // Add right wall if needed
                    if (cell.walls.right && j < cols - 1) {
                        const rightWall = document.createElement('div');
                        rightWall.className = 'maze-wall';
                        rightWall.style.top = `${i * cellSize}px`;
                        rightWall.style.left = `${(j + 1) * cellSize - wallThickness / 2}px`;
                        rightWall.style.width = `${wallThickness}px`;
                        rightWall.style.height = `${cellSize}px`;
                        mazeContainer.appendChild(rightWall);
                    }
                    
                    // Add bottom wall if needed
                    if (cell.walls.bottom && i < rows - 1) {
                        const bottomWall = document.createElement('div');
                        bottomWall.className = 'maze-wall';
                        bottomWall.style.top = `${(i + 1) * cellSize - wallThickness / 2}px`;
                        bottomWall.style.left = `${j * cellSize}px`;
                        bottomWall.style.width = `${cellSize}px`;
                        bottomWall.style.height = `${wallThickness}px`;
                        mazeContainer.appendChild(bottomWall);
                    }
                }
            }
        }
        
        // Create path lines and nodes for navigation
        function createPathLines(cols, rows) {
            try {
                console.log("Creating path lines and nodes");
                
                // Create path nodes at the center of each cell
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const centerX = j * cellSize + cellSize / 2;
                        const centerY = i * cellSize + cellSize / 2;
                        
                        // Create a node at this position
                        const node = {
                            x: centerX,
                            y: centerY,
                            gridX: j,
                            gridY: i,
                            connections: []
                        };
                        
                        // Add to pathNodes array
                        pathNodes.push(node);
                        
                        // Create visible node element
                        const nodeElement = document.createElement('div');
                        nodeElement.className = 'path-node';
                        nodeElement.style.left = `${centerX}px`;
                        nodeElement.style.top = `${centerY}px`;
                        mazeContainer.appendChild(nodeElement);
                    }
                }
                
                // Connect nodes based on maze structure
                connectPathNodes(cols, rows);
                
                // Create path lines between connected nodes
                for (let i = 0; i < pathNodes.length; i++) {
                    const node = pathNodes[i];
                    
                    for (const connectedIndex of node.connections) {
                        const connectedNode = pathNodes[connectedIndex];
                        
                        // Only create path line if this is the "forward" connection
                        // (to avoid duplicate lines)
                        if (i < connectedIndex) {
                            // Create a path line between these nodes
                            const line = document.createElement('div');
                            line.className = 'path-line';
                            
                            if (node.gridX === connectedNode.gridX) {
                                // Vertical path line
                                line.classList.add('vertical');
                                const top = Math.min(node.y, connectedNode.y);
                                const height = Math.abs(node.y - connectedNode.y);
                                
                                line.style.left = `${node.x}px`;
                                line.style.top = `${top}px`;
                                line.style.height = `${height}px`;
                            } else {
                                // Horizontal path line
                                line.classList.add('horizontal');
                                const left = Math.min(node.x, connectedNode.x);
                                const width = Math.abs(node.x - connectedNode.x);
                                
                                line.style.left = `${left}px`;
                                line.style.top = `${node.y}px`;
                                line.style.width = `${width}px`;
                            }
                            
                            mazeContainer.appendChild(line);
                        }
                    }
                }
                
                console.log(`Created ${pathNodes.length} path nodes`);
                
            } catch (error) {
                console.error("Error creating path lines:", error);
                showError("Path creation failed: " + error.message);
            }
        }
        
        // Connect path nodes based on maze structure
        function connectPathNodes(cols, rows) {
            try {
                console.log("Connecting path nodes...");
                
                // Iterate through each cell in the grid
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        // Find the index of the node at this grid position
                        const currentNodeIndex = pathNodes.findIndex(node => node.gridX === x && node.gridY === y);
                        
                        if (currentNodeIndex === -1) continue; // No node at this position
                        
                        const currentNode = pathNodes[currentNodeIndex];
                        
                        // Check each direction for potential connections
                        if (x > 0 && !maze[y][x].walls.left) {
                            // Connect to the node to the left
                            const leftNodeIndex = pathNodes.findIndex(node => node.gridX === x - 1 && node.gridY === y);
                            if (leftNodeIndex !== -1 && !currentNode.connections.includes(leftNodeIndex)) {
                                currentNode.connections.push(leftNodeIndex);
                                pathNodes[leftNodeIndex].connections.push(currentNodeIndex);
                                console.log(`Connected node (${x},${y}) to (${x-1},${y})`);
                            }
                        }
                        
                        if (x < cols - 1 && !maze[y][x].walls.right) {
                            // Connect to the node to the right
                            const rightNodeIndex = pathNodes.findIndex(node => node.gridX === x + 1 && node.gridY === y);
                            if (rightNodeIndex !== -1 && !currentNode.connections.includes(rightNodeIndex)) {
                                currentNode.connections.push(rightNodeIndex);
                                pathNodes[rightNodeIndex].connections.push(currentNodeIndex);
                                console.log(`Connected node (${x},${y}) to (${x+1},${y})`);
                            }
                        }
                        
                        if (y > 0 && !maze[y][x].walls.top) {
                            // Connect to the node above
                            const topNodeIndex = pathNodes.findIndex(node => node.gridX === x && node.gridY === y - 1);
                            if (topNodeIndex !== -1 && !currentNode.connections.includes(topNodeIndex)) {
                                currentNode.connections.push(topNodeIndex);
                                pathNodes[topNodeIndex].connections.push(currentNodeIndex);
                                console.log(`Connected node (${x},${y}) to (${x},${y-1})`);
                            }
                        }
                        
                        if (y < rows - 1 && !maze[y][x].walls.bottom) {
                            // Connect to the node below
                            const bottomNodeIndex = pathNodes.findIndex(node => node.gridX === x && node.gridY === y + 1);
                            if (bottomNodeIndex !== -1 && !currentNode.connections.includes(bottomNodeIndex)) {
                                currentNode.connections.push(bottomNodeIndex);
                                pathNodes[bottomNodeIndex].connections.push(currentNodeIndex);
                                console.log(`Connected node (${x},${y}) to (${x},${y+1})`);
                            }
                        }
                    }
                }
                
                console.log("Path nodes connected");
            } catch (error) {
                console.error("Error connecting path nodes:", error);
                throw new Error("Node connection failed: " + error.message);
            }
        }
        
        // Generate a new maze
        function generateMaze() {
            try {
                console.log("Beginning maze generation");
                
                // Check if the required variables are defined
                if (!difficultySizes || !currentDifficulty || !difficultySizes[currentDifficulty]) {
                    throw new Error(`Invalid difficulty settings: ${currentDifficulty}`);
                }
                
                // Update cell size and wall thickness based on difficulty
                cellSize = difficultySizes[currentDifficulty].cellSize;
                wallThickness = difficultySizes[currentDifficulty].wallThickness;
                
                console.log(`Difficulty: ${currentDifficulty}, cellSize: ${cellSize}, wallThickness: ${wallThickness}`);
                
                // Calculate grid size
                if (typeof mazeWidth !== 'number' || typeof mazeHeight !== 'number') {
                    throw new Error(`Invalid maze dimensions: ${mazeWidth}x${mazeHeight}`);
                }
                
                const cols = Math.floor(mazeWidth / cellSize);
                const rows = Math.floor(mazeHeight / cellSize);
                
                if (cols <= 0 || rows <= 0) {
                    throw new Error(`Invalid grid dimensions: ${cols}x${rows}`);
                }
                
                console.log(`Grid size: ${cols}x${rows}`);
                
                // Clear maze container and reset arrays
                clearMaze();
                
                // Explicitly initialize arrays
                maze = [];
                pathNodes = [];
                
                // Initialize maze grid with cells
                for (let i = 0; i < rows; i++) {
                    const row = [];
                    for (let j = 0; j < cols; j++) {
                        row.push({
                            x: j,
                            y: i,
                            visited: false,
                            walls: { top: true, right: true, bottom: true, left: true }
                        });
                    }
                    maze.push(row);
                }
                
                if (maze.length === 0 || maze[0].length === 0) {
                    throw new Error("Failed to create maze grid");
                }
                
                console.log("Maze grid initialized, generating paths");
                
                // Generate maze using depth-first search algorithm
                const stack = [];
                const startX = 0;
                const startY = 0;
                
                // Check bounds
                if (startY >= maze.length || startX >= maze[0].length) {
                    throw new Error("Start position out of bounds");
                }
                
                // Mark the starting cell as visited
                maze[startY][startX].visited = true;
                stack.push({ x: startX, y: startY });
                
                // Continue until all cells are visited
                while (stack.length > 0) {
                    // Get the current cell
                    const current = stack[stack.length - 1];
                    const { x, y } = current;
                    
                    // Get unvisited neighbors
                    const neighbors = getUnvisitedNeighbors(x, y);
                    
                    if (neighbors.length === 0) {
                        // No unvisited neighbors, backtrack
                        stack.pop();
                    } else {
                        // Choose a random unvisited neighbor
                        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Remove walls between current cell and chosen neighbor
                        if (next.x > x) {
                            // Remove right wall of current and left wall of neighbor
                            maze[y][x].walls.right = false;
                            maze[next.y][next.x].walls.left = false;
                        } else if (next.x < x) {
                            // Remove left wall of current and right wall of neighbor
                            maze[y][x].walls.left = false;
                            maze[next.y][next.x].walls.right = false;
                        } else if (next.y > y) {
                            // Remove bottom wall of current and top wall of neighbor
                            maze[y][x].walls.bottom = false;
                            maze[next.y][next.x].walls.top = false;
                        } else if (next.y < y) {
                            // Remove top wall of current and bottom wall of neighbor
                            maze[y][x].walls.top = false;
                            maze[next.y][next.x].walls.bottom = false;
                        }
                        
                        // Mark the neighbor as visited and push to stack
                        maze[next.y][next.x].visited = true;
                        stack.push(next);
                    }
                }
                
                console.log("Maze paths generated, creating visual elements");
                
                // Create the maze walls
                createMazeWalls(cols, rows);
                
                // Create path lines and nodes for navigation
                createPathLines(cols, rows);
                
                // Add player
                createPlayer(startX, startY);
                
                // Add goal at the opposite corner (bottom-right)
                createGoal(cols - 1, rows - 1);
                
                // Add START and END labels
                createPointLabels(startX, startY, cols - 1, rows - 1);
                
                // Set up player movement
                setupPlayerMovement();
                
                console.log("Maze generation complete");
                
            } catch (error) {
                console.error("Error during maze generation:", error);
                showError("Maze creation failed: " + error.message);
                throw error; // Re-throw to stop execution
            }
        }
        
        // Create the player element
        function createPlayer(x, y) {
            player = document.createElement('div');
            player.id = 'player';
            
            // Scale player size based on cell size (75% of cell size for width, 85% for height)
            const playerWidth = Math.max(cellSize * 0.75, 24); // Minimum 24px
            const playerHeight = Math.max(cellSize * 0.85, 28); // Minimum 28px
            
            player.style.width = `${playerWidth}px`;
            player.style.height = `${playerHeight}px`;
            
            // Position at the center of the starting cell
            const posX = x * cellSize + cellSize / 2;
            const posY = y * cellSize + cellSize / 2;
            
            player.style.left = `${posX}px`;
            player.style.top = `${posY}px`;
            
            mazeContainer.appendChild(player);
        }
        
        // Create the goal element
        function createGoal(x, y) {
            goal = document.createElement('div');
            goal.id = 'goal';
            
            // Position at the center of the goal cell
            const posX = x * cellSize + cellSize / 2;
            const posY = y * cellSize + cellSize / 2;
            
            goal.style.left = `${posX}px`;
            goal.style.top = `${posY}px`;
            goal.style.width = `${cellSize * 0.7}px`;
            goal.style.height = `${cellSize * 0.7}px`;
            
            mazeContainer.appendChild(goal);
        }
        
        // Create START and END labels
        function createPointLabels(startX, startY, endX, endY) {
            // Create START label
            startLabel = document.createElement('div');
            startLabel.id = 'start-label';
            startLabel.className = 'point-label';
            startLabel.textContent = 'START';
            
            // Position slightly above the start point
            const startPosX = startX * cellSize + cellSize / 2;
            const startPosY = startY * cellSize - 15; // Position above the cell
            
            startLabel.style.left = `${startPosX}px`;
            startLabel.style.top = `${startPosY}px`;
            
            // Create END label
            endLabel = document.createElement('div');
            endLabel.id = 'end-label';
            endLabel.className = 'point-label';
            endLabel.textContent = 'FINISH';
            
            // Position slightly below the end point
            const endPosX = endX * cellSize + cellSize / 2;
            const endPosY = endY * cellSize + cellSize + 15; // Position below the cell
            
            endLabel.style.left = `${endPosX}px`;
            endLabel.style.top = `${endPosY}px`;
            
            // Add labels to maze container
            mazeContainer.appendChild(startLabel);
            mazeContainer.appendChild(endLabel);
        }
        
        // Setup player movement with keyboard and drag controls
        function setupPlayerMovement() {
            if (!player || pathNodes.length === 0) {
                console.error("Player or pathNodes not initialized");
                return;
            }
            
            // Reference to player position
            let playerX = parseFloat(player.style.left);
            let playerY = parseFloat(player.style.top);
            let closestNodeIndex = 0;
            
            // SMOOTHER DRAGGING VARIABLES
            let dragPath = []; // Track the path of nodes visited during current drag
            let lastVisitedNode = 0; // Track last node to prevent back-and-forth jumping
            
            // Find the closest node index for starting position
            try {
                updateClosestNodeIndex();
            } catch (error) {
                console.error("Error finding closest node:", error);
                return;
            }
            
            // Define all event handlers using named functions so they can be removed later
            function handleKeyDown(e) {
                if (!isSessionActive) return;
                
                const currentNode = pathNodes[closestNodeIndex];
                let nextNodeIndex = -1;
                
                // Check which connected node to move to based on key press
                switch (e.key) {
                    case 'ArrowUp':
                        // Find node above current node
                        nextNodeIndex = currentNode.connections.find(index => 
                            pathNodes[index].y < currentNode.y && 
                            pathNodes[index].x === currentNode.x
                        );
                        break;
                    case 'ArrowDown':
                        // Find node below current node
                        nextNodeIndex = currentNode.connections.find(index => 
                            pathNodes[index].y > currentNode.y && 
                            pathNodes[index].x === currentNode.x
                        );
                        break;
                    case 'ArrowLeft':
                        // Find node to the left of current node
                        nextNodeIndex = currentNode.connections.find(index => 
                            pathNodes[index].x < currentNode.x && 
                            pathNodes[index].y === currentNode.y
                        );
                        break;
                    case 'ArrowRight':
                        // Find node to the right of current node
                        nextNodeIndex = currentNode.connections.find(index => 
                            pathNodes[index].x > currentNode.x && 
                            pathNodes[index].y === currentNode.y
                        );
                        break;
                    default:
                        return;
                }
                
                // If valid connection found, move to the next node
                if (nextNodeIndex !== undefined && nextNodeIndex !== -1) {
                    moveToNode(nextNodeIndex);
                    e.preventDefault(); // Prevent scrolling
                }
            }
            
            function startDrag(e) {
                if (!isSessionActive) return;
                
                isDragging = true;
                dragPath = [closestNodeIndex]; // Start with current node
                lastVisitedNode = closestNodeIndex;
                
                // Add active class for visual feedback
                player.style.boxShadow = '0 0 30px rgba(111, 211, 245, 1)';
                
                e.preventDefault(); // Prevent scrolling on touch
            }
            
            function drag(e) {
                if (!isDragging || !isSessionActive) return;
                
                // Get container's position relative to viewport
                const rect = mazeContainer.getBoundingClientRect();
                
                let currentX, currentY;
                
                // Get current position relative to the maze container
                if (e.type === 'mousemove') {
                    currentX = e.clientX - rect.left;
                    currentY = e.clientY - rect.top;
                } else if (e.type === 'touchmove') {
                    currentX = e.touches[0].clientX - rect.left;
                    currentY = e.touches[0].clientY - rect.top;
                    e.preventDefault(); // Prevent scrolling on touch
                }
                
                // Find the closest connected node to the drag position
                const currentNode = pathNodes[closestNodeIndex];
                let bestNodeIndex = -1;
                let minDistance = Infinity;
                
                // Check all connected nodes (and their connections for smoother movement)
                const nodesToCheck = new Set([closestNodeIndex]);
                
                // Add all immediately connected nodes
                for (const connectedIndex of currentNode.connections) {
                    nodesToCheck.add(connectedIndex);
                    
                    // Also check nodes connected to those (for smoother diagonal movement)
                    const connectedNode = pathNodes[connectedIndex];
                    for (const secondLevelIndex of connectedNode.connections) {
                        nodesToCheck.add(secondLevelIndex);
                    }
                }
                
                // Find closest node from the candidates
                for (const nodeIndex of nodesToCheck) {
                    const node = pathNodes[nodeIndex];
                    const dx = node.x - currentX;
                    const dy = node.y - currentY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Prefer nodes we haven't visited in this drag to prevent jumping back
                    const visitedPenalty = dragPath.includes(nodeIndex) ? cellSize * 0.5 : 0;
                    const adjustedDistance = distance + visitedPenalty;
                    
                    if (adjustedDistance < minDistance && nodeIndex !== lastVisitedNode) {
                        minDistance = adjustedDistance;
                        bestNodeIndex = nodeIndex;
                    }
                }
                
                // If we found a good node and it's close enough, move there
                if (bestNodeIndex !== -1 && minDistance < cellSize * 0.7) {
                    // Check if there's a valid path from current position to target
                    const path = findPath(closestNodeIndex, bestNodeIndex);
                    
                    if (path.length > 0) {
                        // Move along the path
                        for (let i = 1; i < path.length; i++) {
                            const nodeIndex = path[i];
                            if (!dragPath.includes(nodeIndex)) {
                                dragPath.push(nodeIndex);
                            }
                            moveToNode(nodeIndex);
                            lastVisitedNode = nodeIndex;
                        }
                    }
                }
            }
            
            function endDrag() {
                isDragging = false;
                player.style.boxShadow = '0 0 20px rgba(111, 211, 245, 0.8)';
                dragPath = [];
                lastVisitedNode = closestNodeIndex;
            }
            
            // Simple pathfinding to ensure smooth movement
            function findPath(startIndex, targetIndex) {
                if (startIndex === targetIndex) return [startIndex];
                
                const visited = new Set();
                const queue = [[startIndex]];
                
                while (queue.length > 0) {
                    const path = queue.shift();
                    const currentIndex = path[path.length - 1];
                    
                    if (currentIndex === targetIndex) {
                        return path;
                    }
                    
                    if (!visited.has(currentIndex)) {
                        visited.add(currentIndex);
                        
                        const currentNode = pathNodes[currentIndex];
                        for (const connectedIndex of currentNode.connections) {
                            if (!visited.has(connectedIndex)) {
                                queue.push([...path, connectedIndex]);
                            }
                        }
                    }
                }
                
                return []; // No path found
            }
            
            // Store references to event handlers
            eventHandlers.keydown = handleKeyDown;
            eventHandlers.mousedown = startDrag;
            eventHandlers.touchstart = startDrag;
            eventHandlers.mousemove = drag;
            eventHandlers.touchmove = drag;
            eventHandlers.mouseup = endDrag;
            eventHandlers.touchend = endDrag;
            
            // Attach the event listeners
            mazeContainer.addEventListener('keydown', eventHandlers.keydown);
            player.addEventListener('mousedown', eventHandlers.mousedown);
            player.addEventListener('touchstart', eventHandlers.touchstart, { passive: false });
            document.addEventListener('mousemove', eventHandlers.mousemove);
            document.addEventListener('touchmove', eventHandlers.touchmove, { passive: false });
            document.addEventListener('mouseup', eventHandlers.mouseup);
            document.addEventListener('touchend', eventHandlers.touchend);
            
            function moveToNode(nodeIndex) {
                if (nodeIndex >= 0 && nodeIndex < pathNodes.length) {
                    const targetNode = pathNodes[nodeIndex];
                    
                    // Add path trace if enabled
                    if (showTrace) {
                        addPathTrace(playerX, playerY, targetNode.x, targetNode.y);
                    }
                    
                    // Update player position
                    playerX = targetNode.x;
                    playerY = targetNode.y;
                    player.style.left = `${playerX}px`;
                    player.style.top = `${playerY}px`;
                    closestNodeIndex = nodeIndex;
                    
                    // Check if player reached the goal
                    checkGoalReached();
                }
            }
            
            function updateClosestNodeIndex() {
                // Find the closest node to the player
                if (pathNodes.length === 0) {
                    console.error("No path nodes available");
                    return;
                }
                
                let minDistance = Infinity;
                
                for (let i = 0; i < pathNodes.length; i++) {
                    const node = pathNodes[i];
                    const dx = node.x - playerX;
                    const dy = node.y - playerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestNodeIndex = i;
                    }
                }
            }
            
            function addPathTrace(fromX, fromY, toX, toY) {
                const trace = document.createElement('div');
                trace.className = 'path-trace';
                
                // Calculate center point and dimensions
                const centerX = (fromX + toX) / 2;
                const centerY = (fromY + toY) / 2;
                const width = Math.abs(toX - fromX) + 10; // Add a bit of padding
                const height = Math.abs(toY - fromY) + 10;
                
                // Position trace
                trace.style.left = `${centerX - width / 2}px`;
                trace.style.top = `${centerY - height / 2}px`;
                trace.style.width = `${width}px`;
                trace.style.height = `${height}px`;
                
                // Add to container and track
                mazeContainer.appendChild(trace);
                pathTraces.push(trace);
            }
            
            function checkGoalReached() {
                // Get goal position
                const goalX = parseFloat(goal.style.left);
                const goalY = parseFloat(goal.style.top);
                
                // Calculate distance between player and goal
                const dx = playerX - goalX;
                const dy = playerY - goalY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // If player is close enough to goal, consider it reached
                const goalRadius = parseFloat(goal.style.width) / 2;
                if (distance < goalRadius) {
                    completeCurrentMaze();
                }
            }
        }
    </script>
</body>
</html>